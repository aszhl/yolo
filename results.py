# Ultralytics YOLO ðŸš€, AGPL-3.0 license
"""
Ultralytics Results, Boxes and Masks classes for handling inference results.

Usage: See https://docs.ultralytics.com/modes/predict/
"""

from copy import deepcopy
from functools import lru_cache
from pathlib import Path

import numpy as np
import torch
import time

from ultralytics.data.augment import LetterBox
from ultralytics.utils import LOGGER, SimpleClass, ops
from ultralytics.utils.plotting import Annotator, colors, save_one_box
from ultralytics.utils.torch_utils import smart_inference_mode
#from word import word_detect

import paddlehub as hub
ocr = hub.Module(name="ch_pp-ocrv3", enable_mkldnn=True)# mkldnnåŠ é€Ÿä»…åœ¨CPUä¸‹æœ‰æ•ˆ

class BaseTensor(SimpleClass):
    """Base tensor class with additional methods for easy manipulation and device handling."""

    def __init__(self, data, orig_shape) -> None:
        """
        Initialize BaseTensor with data and original shape.

        Args:
            data (torch.Tensor | np.ndarray): Predictions, such as bboxes, masks and keypoints.
            orig_shape (tuple): Original shape of image.
        """
        assert isinstance(data, (torch.Tensor, np.ndarray))
        self.data = data
        self.orig_shape = orig_shape

    @property
    def shape(self):
        """Return the shape of the data tensor."""
        return self.data.shape

    def cpu(self):
        """Return a copy of the tensor on CPU memory."""
        return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.cpu(), self.orig_shape)

    def numpy(self):
        """Return a copy of the tensor as a numpy array."""
        return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.numpy(), self.orig_shape)

    def cuda(self):
        """Return a copy of the tensor on GPU memory."""
        return self.__class__(torch.as_tensor(self.data).cuda(), self.orig_shape)

    def to(self, *args, **kwargs):
        """Return a copy of the tensor with the specified device and dtype."""
        return self.__class__(torch.as_tensor(self.data).to(*args, **kwargs), self.orig_shape)

    def __len__(self):  # override len(results)
        """Return the length of the data tensor."""
        return len(self.data)

    def __getitem__(self, idx):
        """Return a BaseTensor with the specified index of the data tensor."""
        return self.__class__(self.data[idx], self.orig_shape)


class Results(SimpleClass):
    """
    A class for storing and manipulating inference results.

    Args:
        orig_img (numpy.ndarray): The original image as a numpy array.
        path (str): The path to the image file.
        names (dict): A dictionary of class names.
        boxes (torch.tensor, optional): A 2D tensor of bounding box coordinates for each detection.
        masks (torch.tensor, optional): A 3D tensor of detection masks, where each mask is a binary image.
        probs (torch.tensor, optional): A 1D tensor of probabilities of each class for classification task.
        keypoints (List[List[float]], optional): A list of detected keypoints for each object.

    Attributes:
        orig_img (numpy.ndarray): The original image as a numpy array.
        orig_shape (tuple): The original image shape in (height, width) format.
        boxes (Boxes, optional): A Boxes object containing the detection bounding boxes.
        masks (Masks, optional): A Masks object containing the detection masks.
        probs (Probs, optional): A Probs object containing probabilities of each class for classification task.
        keypoints (Keypoints, optional): A Keypoints object containing detected keypoints for each object.
        speed (dict): A dictionary of preprocess, inference, and postprocess speeds in milliseconds per image.
        names (dict): A dictionary of class names.
        path (str): The path to the image file.
        _keys (tuple): A tuple of attribute names for non-empty attributes.
    """

    def __init__(self, orig_img, path, names, boxes=None, masks=None, probs=None, keypoints=None) -> None:
        """Initialize the Results class."""
        self.orig_img = orig_img
        self.orig_shape = orig_img.shape[:2]
        self.boxes = Boxes(boxes, self.orig_shape) if boxes is not None else None  # native size boxes
        self.masks = Masks(masks, self.orig_shape) if masks is not None else None  # native size or imgsz masks
        self.probs = Probs(probs) if probs is not None else None
        self.keypoints = Keypoints(keypoints, self.orig_shape) if keypoints is not None else None
        self.speed = {'preprocess': None, 'inference': None, 'postprocess': None}  # milliseconds per image
        self.names = names
        self.path = path
        self.save_dir = None
        self._keys = 'boxes', 'masks', 'probs', 'keypoints'

    def __getitem__(self, idx):
        """Return a Results object for the specified index."""
        return self._apply('__getitem__', idx)

    def __len__(self):
        """Return the number of detections in the Results object."""
        for k in self._keys:
            v = getattr(self, k)
            if v is not None:
                return len(v)

    def update(self, boxes=None, masks=None, probs=None):
        """Update the boxes, masks, and probs attributes of the Results object."""
        if boxes is not None:
            ops.clip_boxes(boxes, self.orig_shape)  # clip boxes
            self.boxes = Boxes(boxes, self.orig_shape)
        if masks is not None:
            self.masks = Masks(masks, self.orig_shape)
        if probs is not None:
            self.probs = probs

    def _apply(self, fn, *args, **kwargs):
        """
        Applies a function to all non-empty attributes and returns a new Results object with modified attributes. This
        function is internally called by methods like .to(), .cuda(), .cpu(), etc.

        Args:
            fn (str): The name of the function to apply.
            *args: Variable length argument list to pass to the function.
            **kwargs: Arbitrary keyword arguments to pass to the function.

        Returns:
            Results: A new Results object with attributes modified by the applied function.
        """
        r = self.new()
        for k in self._keys:
            v = getattr(self, k)
            if v is not None:
                setattr(r, k, getattr(v, fn)(*args, **kwargs))
        return r

    def cpu(self):
        """Return a copy of the Results object with all tensors on CPU memory."""
        return self._apply('cpu')

    def numpy(self):
        """Return a copy of the Results object with all tensors as numpy arrays."""
        return self._apply('numpy')

    def cuda(self):
        """Return a copy of the Results object with all tensors on GPU memory."""
        return self._apply('cuda')

    def to(self, *args, **kwargs):
        """Return a copy of the Results object with tensors on the specified device and dtype."""
        return self._apply('to', *args, **kwargs)

    def new(self):
        """Return a new Results object with the same image, path, and names."""
        return Results(orig_img=self.orig_img, path=self.path, names=self.names)

    def plot(
        self,
        conf=True,
        line_width=None,
        font_size=None,
        font=r'E:\Anaconda\envs\y8\Lib\site-packages\matplotlib\mpl-data\fonts\ttf\simhei.ttf',
        pil=True,
        img=None,
        im_gpu=None,
        kpt_radius=5,
        kpt_line=True,
        labels=True,
        boxes=True,
        masks=True,
        probs=True,
    ):
        """
        Plots the detection results on an input RGB image. Accepts a numpy array (cv2) or a PIL Image.

        Args:
            conf (bool): Whether to plot the detection confidence score.
            line_width (float, optional): The line width of the bounding boxes. If None, it is scaled to the image size.
            font_size (float, optional): The font size of the text. If None, it is scaled to the image size.
            font (str): The font to use for the text.
            pil (bool): Whether to return the image as a PIL Image.
            img (numpy.ndarray): Plot to another image. if not, plot to original image.
            im_gpu (torch.Tensor): Normalized image in gpu with shape (1, 3, 640, 640), for faster mask plotting.
            kpt_radius (int, optional): Radius of the drawn keypoints. Default is 5.
            kpt_line (bool): Whether to draw lines connecting keypoints.
            labels (bool): Whether to plot the label of bounding boxes.
            boxes (bool): Whether to plot the bounding boxes.
            masks (bool): Whether to plot the masks.
            probs (bool): Whether to plot classification probability

        Returns:
            (numpy.ndarray): A numpy array of the annotated image.

        Example:
            ```python
            from PIL import Image
            from ultralytics import YOLO

            model = YOLO('yolov8n.pt')
            results = model('bus.jpg')  # results list
            for r in results:
                im_array = r.plot()  # plot a BGR numpy array of predictions
                im = Image.fromarray(im_array[..., ::-1])  # RGB PIL image
                im.show()  # show image
                im.save('results.jpg')  # save image
            ```
        """
        #print(img)
        if img is None and isinstance(self.orig_img, torch.Tensor):
            img = (self.orig_img[0].detach().permute(1, 2, 0).contiguous() * 255).to(torch.uint8).cpu().numpy()


        names = self.names
        fault='æ— æ•…éšœ'
        final_text = {}  # æœ€ç»ˆè°ƒç”¨æ•°æ®
        pred_boxes, show_boxes = self.boxes, boxes
        pred_masks, show_masks = self.masks, masks
        pred_probs, show_probs = self.probs, probs
        annotator = Annotator(
            deepcopy(self.orig_img if img is None else img),
            line_width,
            font_size,
            font,
            pil or (pred_probs is not None and show_probs),  # Classify tasks default to pil=True
            example=names)

        # Plot Segment results
        if pred_masks and show_masks:
            if im_gpu is None:
                img = LetterBox(pred_masks.shape[1:])(image=annotator.result())
                im_gpu = torch.as_tensor(img, dtype=torch.float16, device=pred_masks.data.device).permute(
                    2, 0, 1).flip(0).contiguous() / 255
            idx = pred_boxes.cls if pred_boxes else range(len(pred_masks))
            annotator.masks(pred_masks.data, colors=[colors(x, True) for x in idx], im_gpu=im_gpu)

        # Plot Detect results
        if pred_boxes and show_boxes:
            #print(names)
            text_num=[]
            text_fault=''
            warn_fault=[]
            type_number = ''
            set_label = False
            comen_faut={   'å‘¼å¸æœºæ— æ³•å¯åŠ¨':{'åŽŸå› ':'1.æ²¡æœ‰è¿žæŽ¥ AC ç”µæºï¼Œä¸”ç”µæ± ç”µé‡ä¸è¶³;2.AC è¾“å…¥æ’åº§ä¿é™©ä¸ç†”æ–­ï¼Œä¸”ç”µæ± ç”µé‡ä¸è¶³;3.æ˜¾ç¤ºç”µç¼†ï¼ˆæ¯æ¿å¤„æˆ–ä¸»æœºå¤–éƒ¨è¿žæŽ¥å™¨å¤„ï¼‰è„±è½æˆ–è¿žæŽ¥ä¸å¯é ;4. AC-DC æ¿ç¡¬ä»¶ç”µè·¯æ•…éšœå¯¼è‡´æ²¡æœ‰18.8V ç”µæºè¾“å‡ºï¼Œä¸”ç”µæ± ç”µé‡ä¸è¶³;5.DC-DC æ¿ç¡¬ä»¶ç”µè·¯æ•…éšœå¯¼è‡´æ²¡æœ‰5Vã€3.3Vã€7Vã€12V ç­‰ç›´æµç”µæºè¾“å‡º','è§£å†³åŠžæ³•':'1.æ£€æŸ¥å¹¶ç¡®ä¿ AC ç”µæºæ­£ç¡®è¿žæŽ¥;2.æ›´æ¢ä¿é™©ä¸ï¼Œæ›´æ¢ä¿é™©ä¸åŽå¦‚æžœå¼€æœºæ—¶æ•…éšœä»ç„¶å­˜åœ¨ï¼Œåˆ™è¯´æ˜Žæœºå™¨å†…éƒ¨å­˜åœ¨çŸ­è·¯çŽ°è±¡;3.æ£€æŸ¥å¹¶ç¡®ä¿çº¿ç¼†å¯é è¿žæŽ¥ï¼Œå¹¶ç¡®ä¿æ˜¾ç¤ºç”µç¼†çš„ç´§å›ºèžºé’‰ä¸ºæ‹§ç´§çŠ¶æ€;4.æ£€æŸ¥å¹¶ç¡®ä¿çº¿ç¼†å¯é è¿žæŽ¥;5.æ›´æ¢ AC-DC æ¿;6.æ›´æ¢ DC-DC æ¿'},
                           'å±å¹•æ²¡æœ‰æ˜¾ç¤º(é»‘å±)':{'åŽŸå› ':'1.é€†å˜å™¨è¿žæŽ¥çº¿ï¼ˆåŒ…æ‹¬é€†å˜å™¨è¾“å…¥çº¿å’Œè¾“å‡ºçº¿ï¼‰è„±è½æˆ–è¿žæŽ¥ä¸å¯é ;2.é€†å˜å™¨æŸå;3.ä¸»æŽ§æ¿ç¡¬ä»¶æ•…éšœï¼Œå¯¼è‡´èƒŒå…‰ä½¿èƒ½ä¿¡å·è¾“å‡ºæ— æ•ˆç”µå¹³;4.ä¸»æŽ§æ¿è½¯ä»¶æ•…éšœï¼Œå¯¼è‡´èƒŒå…‰ä½¿èƒ½ä¿¡å·è¾“å‡ºæ— æ•ˆç”µå¹³;5.LCD æŸå','è§£å†³åŠžæ³•':'1.æ£€æŸ¥å¹¶ç¡®ä¿çº¿ç¼†å¯é è¿žæŽ¥;2.æ›´æ¢é€†å˜å™¨;3.æ›´æ¢ä¸»æŽ§æ¿;4.å‡çº§ä¸»æŽ§æ¿è½¯ä»¶;5.æ›´æ¢ LCD'},
                           'ç™½å±':{'åŽŸå› ':'1.æ˜¾ç¤ºç”µç¼†ï¼ˆLCD å¤„ï¼‰è„±è½æˆ–è¿žæŽ¥ä¸å¯é ;2.ä¸»æŽ§æ¿ç¡¬ä»¶æ•…éšœï¼Œå¯¼è‡´ LCD ä¾›ç”µç”µæº 3.3V æ— è¾“å‡ºæˆ–è¾“å‡ºå¼‚å¸¸;3.LCDæŸå','è§£å†³åŠžæ³•':'1.æ£€æŸ¥å¹¶ç¡®ä¿çº¿ç¼†å¯é è¿žæŽ¥;2.æ›´æ¢ä¸»æŽ§æ¿;3.æ›´æ¢ LCD'},
                           'èŠ±å±':{'åŽŸå› ':'æ˜¾ç¤ºç”µç¼†ï¼ˆLCD å¤„ï¼‰è„±è½æˆ–è¿žæŽ¥ä¸å¯é ï¼Œå¯¼è‡´éƒ¨åˆ†é¢œè‰²ä¿¡å·ä¸¢å¤±','è§£å†³åŠžæ³•':'æ£€æŸ¥å¹¶ç¡®ä¿çº¿ç¼†å¯é è¿žæŽ¥'},
                           'é£Žæ‰‡æ•…éšœ':{'åŽŸå› ':'1.é£Žæ‰‡å µå¡ž;2.é£Žæ‰‡è¿žæŽ¥çº¿è„±è½æˆ–é£Žæ‰‡æ•…éšœ;3.DC-DC æ¿ç»™é£Žæ‰‡ä¾›ç”µçš„ 12V æŸå','è§£å†³åŠžæ³•':'1.æŸ¥çœ‹é£Žæ‰‡å µå¡žæƒ…å†µï¼Œå¹¶æ¸…é™¤éšœç¢ç‰©;2.é‡çŽ°æ’æ‹”é£Žæ‰‡è¿žæŽ¥çº¿æˆ–æ›´æ¢é£Žæ‰‡;3.æ›´æ¢ DC-DC æ¿'},
                           'æ¶¡è½®è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.æ¶¡è½®ä¾›ç”µè¿žæŽ¥çº¿æ–­å¼€;2.æ¶¡è½®æ•…éšœ','è§£å†³åŠžæ³•':'1.ç¡®è®¤æ¶¡è½®ä¾›ç”µç”µçº¿è¿žæŽ¥æ­£ç¡®;2.æ›´æ¢æ¶¡è½®'},
                           '02æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.é«˜åŽ‹æ°§ä¾›æ°”ä¸è¶³ã€‚2.ä½ŽåŽ‹æ°§é€šæ°”ã€‚3.æ°§æ°”æ¯”ä¾‹é˜€ä¸Ž02æµé‡ä¼ æ„Ÿå™¨åå·®è¾ƒå¤§ã€‚4.æ°§æ°”æ¯”ä¾‹é˜€æ•…éšœã€‚5.02æµé‡ä¼ æ„Ÿå™¨æ•…éšœ','è§£å†³åŠžæ³•':'1.æ£€æŸ¥æ˜¯å¦è¿žæŽ¥é«˜åŽ‹æ°§æ°”æºï¼Œä¸”æ°”æºæ˜¯å¦å……è¶³ã€‚2.åœ¨ã€ä¸»èœå•ã€‘â†’ã€ç»´æŠ¤ã€‘â†’ã€ç”¨æˆ·ç»´æŠ¤ã€‘â†’è¾“å…¥ç”¨æˆ·ç»´æŠ¤å¯†ç â†’ã€è®¾ç½®ã€‘â†’ã€æ°”æºã€‘â†’ã€æ°§æ°”æ°”æºç±»åž‹ã€‘æŸ¥çœ‹é€‰æ‹©çš„æ˜¯å¦æ˜¯ä½ŽåŽ‹æ°§ï¼Œå¦‚æžœæ˜¯ï¼Œè¯·åˆ‡æ¢ä¸ºé«˜åŽ‹æ°§ã€‚3.é‡æ–°æ‰§è¡Œæµé‡æ ¡å‡†ã€‚4.åœ¨é˜€é—¨è¯Šæ–­ç•Œé¢è¯Šæ–­æ°§æ°”æ¯”ä¾‹é˜€æ˜¯å¦å¼‚å¸¸ï¼ˆå‚è§ å¸æ°”é˜€æˆ–æ°§æ°”æ¯”ä¾‹é˜€çŠ¶æ€å¼‚å¸¸è¯Šæ–­ï¼‰ï¼Œå¦‚æžœå¼‚å¸¸æ›´æ¢æ°§æ°”æ¯”ä¾‹é˜€ï¼Œé‡æ–°æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚5.æ£€æŸ¥O2æµé‡ä¼ æ„Ÿå™¨æ˜¯å¦æ­£ç¡®è¿žæŽ¥ï¼Œå¦‚æžœæ•…éšœä»ç„¶å­˜åœ¨ï¼Œè¯·æ›´æ¢ O2 æµé‡ä¼ æ„Ÿå™¨ï¼Œé‡æ–°æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚6.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'å¸æ°”æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.å¸æ°”æµé‡ä¼ æ„Ÿå™¨ä¸Žå¸æ°”é˜€çš„å¼€é˜€æµé€Ÿåå·®è¾ƒå¤§ã€‚2.å¸æ°”é˜€æ•…éšœã€‚3.å¸æ°”æµé‡ä¼ æ„Ÿå™¨æ•…éšœ','è§£å†³åŠžæ³•':'1.é‡æ–°æ‰§è¡Œæµé‡æ ¡å‡†ï¼Œå‚è§æµé‡æ ¡å‡†ã€‚2.åœ¨é˜€é—¨è¯Šæ–­ç•Œé¢è¯Šæ–­å¸æ°”é˜€æ˜¯å¦å¼‚å¸¸ï¼ˆå¸æ°”é˜€æˆ–æ°§æ°”æ¯”ä¾‹é˜€çŠ¶æ€å¼‚å¸¸è¯Šæ–­ï¼‰ï¼Œå¦‚æžœå¼‚å¸¸æ›´æ¢å¸æ°”é˜€ï¼Œé‡æ–°æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚3.æ£€æŸ¥å¸æ°”æµé‡ä¼ æ„Ÿå™¨æ˜¯å¦æ­£ç¡®è¿žæŽ¥ï¼Œå¦‚æžœæ•…éšœä»ç„¶å­˜åœ¨ï¼Œæ›´æ¢å¸æ°”æµé‡ä¼ æ„Ÿå™¨ï¼Œé‡æ–°æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚4.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.Ypieceæ²¡å µä½æˆ–ç®¡è·¯æœªè¿žæŽ¥;2.å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨ä¸Žå¸æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹é‡æµé€Ÿåå·®è¾ƒå¤§;3.å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨æ•…éšœ','è§£å†³åŠžæ³•':'1.æ£€æŸ¥ Ypiece æ˜¯å¦å µä½æˆ–ç®¡è·¯æ˜¯å¦è¿žæŽ¥ã€‚2.é‡æ–°æ‰§è¡Œæµé‡æ ¡å‡†ã€‚3.æ£€æŸ¥å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨æ˜¯å¦æ­£ç¡®è¿žæŽ¥ï¼Œå¦‚æžœæ•…éšœä»ç„¶å­˜åœ¨ï¼Œæ›´æ¢å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨ï¼Œé‡æ–°æ‰§è¡Œæµé‡æ ¡å‡†å’Œç³»ç»Ÿè‡ªæ£€ã€‚4.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'åŽ‹åŠ›ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.Ypiece æ²¡å µä½æˆ–ç®¡è·¯æœªè¿žæŽ¥ã€‚2.å¸æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨ã€å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡åŽ‹åŠ›å’Œå‘¼æ°”é˜€å¼€é˜€åŽ‹åŠ›åå·®è¾ƒå¤§ã€‚3.å¸æ°”åŽ‹åŠ›ã€å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨é‡‡æ ·ç®¡æœªè¿žæŽ¥æˆ–æ¼æ°”ã€‚4.å‘¼æ°”é˜€æœªå®‰è£…æˆ–å‘¼æ°”é˜€ä¾›ç”µå¼‚å¸¸ã€‚5.å‘¼æ°”é˜€å¼‚å¸¸','è§£å†³åŠžæ³•':'1.æ£€æŸ¥ Ypiece æ˜¯å¦å µä½æˆ–ç®¡è·¯æ˜¯å¦è¿žæŽ¥ã€‚2.é‡æ–°æ‰§è¡ŒåŽ‹åŠ›æ ¡å‡†ã€‚3.ç¡®è®¤å¸æ°”åŽ‹åŠ›ã€å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨é‡‡æ ·ç®¡æ˜¯å¦å®Œå¥½ï¼ˆæ— æ–­è£‚ï¼‰ä¸”æ­£ç¡®è¿žæŽ¥ã€‚4.ç¡®è®¤å‘¼æ°”é˜€ä¾›ç”µç”µçº¿è¿žæŽ¥æ­£ç¡®ï¼Œå‘¼æ°”é˜€å®‰è£…æ­£ç¡®ï¼Œé‡æ–°æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚5.åœ¨é˜€é—¨è¯Šæ–­ç•Œé¢è¯Šæ–­å‘¼æ°”é˜€æ˜¯å¦å¼‚å¸¸ï¼ˆå‚è§å‘¼æ°”é˜€çŠ¶æ€å¼‚å¸¸è¯Šæ–­ï¼‰ï¼Œå¦‚æžœå¼‚å¸¸ï¼Œåˆ™æ›´æ¢å‘¼æ°”é˜€ï¼Œå†æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚6.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'å‘¼æ°”é˜€è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.Ypieceæ²¡å µä½æˆ–ç®¡è·¯æœªè¿žæŽ¥ã€‚2.å¸æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨ã€å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡åŽ‹åŠ›å’Œå‘¼æ°”é˜€å¼€é˜€åŽ‹åŠ›åå·®è¾ƒå¤§ã€‚3.å¸æ°”åŽ‹åŠ›ã€å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨é‡‡æ ·ç®¡æœªè¿žæŽ¥æˆ–æ¼æ°”ã€‚4.å‘¼æ°”é˜€æœªå®‰è£…æˆ–å‘¼æ°”é˜€ä¾›ç”µå¼‚å¸¸ã€‚5.å‘¼æ°”é˜€å¼‚å¸¸','è§£å†³åŠžæ³•':'1.æ£€æŸ¥ Ypiece æ˜¯å¦å µä½æˆ–ç®¡è·¯æ˜¯å¦è¿žæŽ¥ã€‚2.é‡æ–°æ‰§è¡ŒåŽ‹åŠ›æ ¡å‡†ã€‚3.ç¡®è®¤å¸æ°”åŽ‹åŠ›ã€å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨é‡‡æ ·ç®¡æ˜¯å¦å®Œå¥½ï¼ˆæ— æ–­è£‚ï¼‰ä¸”æ­£ç¡®è¿žæŽ¥ã€‚4.ç¡®è®¤å‘¼æ°”é˜€ä¾›ç”µç”µçº¿è¿žæŽ¥æ­£ç¡®ï¼Œå‘¼æ°”é˜€å®‰è£…æ­£ç¡®ï¼Œé‡æ–°æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚5.åœ¨é˜€é—¨è¯Šæ–­ç•Œé¢è¯Šæ–­å‘¼æ°”é˜€æ˜¯å¦å¼‚å¸¸ï¼ˆå‚è§å‘¼æ°”é˜€çŠ¶æ€å¼‚å¸¸è¯Šæ–­ï¼‰ï¼Œå¦‚æžœå¼‚å¸¸ï¼Œåˆ™æ›´æ¢å‘¼æ°”é˜€ï¼Œå†æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚6.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'å®‰å…¨é˜€è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.Ypieceæ²¡å µä½æˆ–ç®¡è·¯æœªè¿žæŽ¥ã€‚2.å®‰å…¨é˜€ä¾›ç”µå¼‚å¸¸ã€‚3.å®‰å…¨é˜€å¼‚å¸¸ã€‚','è§£å†³åŠžæ³•':'1.æ£€æŸ¥ Ypiece æ˜¯å¦å µä½æˆ–ç®¡è·¯æ˜¯å¦è¿žæŽ¥ã€‚2.ç¡®è®¤å®‰å…¨é˜€ä¾›ç”µç”µçº¿è¿žæŽ¥æ­£å¸¸ã€‚3.åœ¨é˜€é—¨è¯Šæ–­ç•Œé¢è¯Šæ–­å®‰å…¨é˜€æ˜¯å¦å¼‚å¸¸ï¼ˆå‚è§ å®‰å…¨é˜€çŠ¶æ€å¼‚å¸¸è¯Šæ–­ï¼‰ï¼Œå¦‚æžœå¼‚å¸¸ï¼Œæ›´æ¢å®‰å…¨é˜€ï¼Œé‡æ–°æ‰§è¡Œç³»ç»Ÿè‡ªæ£€ã€‚4.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'æ³„æ¼é‡è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.Ypieceæ²¡å µä½æˆ–ç®¡è·¯æœªè¿žæŽ¥ã€‚2.å¸æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•æˆ–åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹è¯•å¤±è´¥ã€‚','è§£å†³åŠžæ³•':'1.æ£€æŸ¥ Ypiece æ˜¯å¦å µä½æˆ–ç®¡è·¯æ˜¯å¦è¿žæŽ¥ã€‚2.å¸æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•å’ŒåŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹è¯•æˆåŠŸåŽï¼Œå†è¿›è¡Œæ³„æ¼æµ‹è¯•ã€‚'},
                           'é¡ºåº”æ€§è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.Ypieceæ²¡å µä½æˆ–ç®¡è·¯æœªè¿žæŽ¥ã€‚2.å¸æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•æˆ–åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹è¯•å¤±è´¥ã€‚','è§£å†³åŠžæ³•':'1.æ£€æŸ¥ Ypiece æ˜¯å¦å µä½æˆ–ç®¡è·¯æ˜¯å¦è¿žæŽ¥ã€‚2.å¸æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•å’ŒåŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹è¯•æˆåŠŸåŽï¼Œå†è¿›è¡Œæ³„æ¼æµ‹è¯•ã€‚'},
                           'ç®¡è·¯é˜»åŠ›è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.Ypieceæ²¡å µä½æˆ–ç®¡è·¯æœªè¿žæŽ¥ã€‚ 2.å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•æˆ–åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹è¯•å¤±è´¥ã€‚','è§£å†³åŠžæ³•':'1.æ£€æŸ¥ Ypiece æ˜¯å¦å µä½æˆ–ç®¡è·¯æ˜¯å¦è¿žæŽ¥ã€‚2.å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•å’ŒåŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹è¯•æˆåŠŸåŽï¼Œå†è¿›è¡Œç®¡è·¯é˜»åŠ›æµ‹è¯•ã€‚'},
                           '02ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥':{'åŽŸå› ':'1.ç•Œé¢æ°§ç›‘æµ‹åŠŸèƒ½å…³é—­ã€‚2.æ°§ä¼ æ„Ÿå™¨æœªè¿žæŽ¥æˆ–æ°§ä¼ æ„Ÿå™¨å¤±æ•ˆã€‚3.æ¶¡è½®æµ‹è¯•æˆ–O2æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•æˆ–å¸æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•å¤±è´¥ã€‚','è§£å†³åŠžæ³•':'1.å¼€å¯æ°§ç›‘æµ‹åŠŸèƒ½ã€‚2.ç¡®ä¿æ°§ä¼ æ„Ÿå™¨è¿žæŽ¥æ­£ç¡®ï¼Œç•Œé¢æ— ä»»ä½•ä¸Žæ°§ä¼ æ„Ÿå™¨ç›¸å…³çš„æŠ¥è­¦ï¼Œé‡æ–°è¿›è¡Œæ°§ä¼ æ„Ÿå™¨æµ‹è¯•ã€‚3.æ¶¡è½®æµ‹è¯•ã€O2 æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•ã€å¸æ°”æµé‡ä¼ æ„Ÿå™¨æµ‹è¯•éƒ½æˆåŠŸåŽï¼Œå†è¿›è¡Œæ°§ä¼ æ„Ÿå™¨æµ‹è¯•ã€‚4.è¿›è¡Œ O2 ä¼ æ„Ÿå™¨æ ¡å‡†ã€‚5.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'Wifiæ¨¡å—å·¥ä½œå¼‚å¸¸':{'åŽŸå› ':'1.Wifiå¤©çº¿è„±è½æˆ–æ–­è£‚;2.Wifiæ¨¡å—æŸå;3.ç›‘æŽ§ä¸»æ¿å‡ºçŽ°æ•…éšœ','è§£å†³åŠžæ³•':'1.é‡æ–°æ’æ‹” wifi å¤©çº¿æˆ–æ›´æ¢å¤©çº¿;2.æ›´æ¢ wifi æ¨¡å—;3.æ›´æ¢ç›‘æŽ§æ¨¡å—æ¿å¡ç»„ä»¶'},
                           'ä¸»æµC02æˆ–æ—æµæ¨¡å—å¼‚å¸¸':{'åŽŸå› ':'1.CO2æ¨¡å—ä¸Žç›‘æŽ§ä¸»æ¿çš„è¿žæŽ¥çº¿å‡ºçŽ°è„±è½æˆ–æ–­å¼€;2.CO2æ¨¡å—è‡ªèº«æ•…éšœ;3.ç›‘æŽ§æ¨¡å—ä¸»æ¿ä¸²å£é€šè®¯å‡ºçŽ°å¼‚å¸¸','è§£å†³åŠžæ³•':'1.é‡æ–°æ’æ‹”æˆ–æ›´æ¢ç›¸å…³çš„çº¿æ;2.æ›´æ¢CO2æ¨¡å—;3.æ›´æ¢ç›‘æŽ§æ¨¡å—ä¸»æ¿ç»„ä»¶'},
                           'æ—¥æœŸæ—¶é—´æ•…éšœ':{'åŽŸå› ':'è¯·é‡æ–°è®¾ç½®æ—¥æœŸå’Œæ—¶é—´ï¼šç³»ç»Ÿä¸­æ²¡æœ‰çº½æ‰£ç”µæ± ï¼Œæˆ–ç”µæ± ä¸­æ²¡æœ‰ç”µé‡ã€‚','è§£å†³åŠžæ³•':'1.æ›´æ¢çº½æ‰£ç”µæ± ï¼Œå¹¶é‡æ–°è®¾ç½®æ—¥æœŸå’Œæ—¶é—´ã€‚2.æ•…éšœä»å­˜åœ¨ï¼Œéœ€æ›´æ¢ä¸»æŽ§æ¿ã€‚'},
                           'å‘¼æœ«æ­£åŽ‹è¿‡é«˜': {'åŽŸå› ': 'å‘¼æœ«æ­£åŽ‹ç›‘æµ‹å€¼é«˜äºŽPEEPè®¾ç½®å€¼+5cmH2Oã€‚','è§£å†³æ–¹æ³•': '1.å‚è§åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼›2.æ£€æŸ¥å‚æ•°è®¾ç½®ã€‚'},
                           'å‘¼æœ«æ­£åŽ‹è¿‡ä½Ž': {'åŽŸå› ': 'å‘¼æœ«æ­£åŽ‹ç›‘æµ‹å€¼é«˜äºŽPEEPè®¾ç½®å€¼+5cmH2Oã€‚','è§£å†³æ–¹æ³•': '1. å‚è§åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼›2.æ£€æŸ¥å‘¼æ°”é˜€å®‰è£…æ˜¯å¦æ­£ç¡®ï¼› 3.æ£€æŸ¥å‚æ•°è®¾ç½®ã€‚'},
                           'ç®¡é“å µå¡ž': {'åŽŸå› ': 'ç—…äººç«¯ç®¡è·¯å‡ºçŽ°é˜»å¡ž', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ç—…äººç«¯ç®¡è·¯æ˜¯å¦æœ‰é˜»å¡žï¼Œå¦‚æžœæœ‰ï¼Œè¯·ç–é€šï¼› 2.å‚è§æµé‡ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥æµé‡ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼› 3. å‚è§ åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ã€‚'},
                           'å¸æ°”æ”¯è·¯ç®¡é“å µå¡ž': {'åŽŸå› ': 'æ°§ç–—æ—¶ï¼Œç—…äººç«¯ç®¡è·¯å‡ºçŽ°å¼¯æŠ˜æˆ–é˜»å¡ž;', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ç—…äººç«¯ç®¡è·¯æ˜¯å¦æœ‰é˜»å¡žæˆ–å¼¯æŠ˜ï¼Œå¦‚æžœæœ‰ï¼Œè¯·ç–é€šï¼›2.å‚è§åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥å¸æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨ã€‚å¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ã€‚'},
                           'æ°”é“åŽ‹åŠ›è¿‡é«˜': {'åŽŸå› ': 'ç—…äººæ°”é“åŽ‹åŠ›æŒç»­åœ¨ä¸€ä¸ªè¾ƒé«˜æ°´å¹³', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥å‚æ•°è®¾ç½®ï¼›2. å‚è§åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†'},
                           'ç®¡é“æ³„æ¼': {'åŽŸå› ': 'ç—…äººç«¯ç®¡è·¯å‡ºçŽ°äº†æ³„æ¼', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ç—…äººç«¯ç®¡è·¯æ˜¯å¦æœ‰æ³„æ¼ï¼Œå¦‚æžœæ³„æ¼è¯·æ›´æ¢ç®¡è·¯ï¼›2. å‚è§æµé‡ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥æµé‡ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼› 3. å‚è§åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ã€‚'},
                           'ç®¡é“æ–­å¼€': {'åŽŸå› ': 'ç—…äººç«¯ç®¡è·¯è„±è½', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ç—…äººç«¯ç®¡è·¯æ˜¯å¦è„±è½æˆ–æ¾åŠ¨ï¼Œå¦‚æžœæœ‰ï¼Œè¯·é‡æ–°è¿žæŽ¥ï¼› 2. å‚è§ æµé‡ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥æµé‡ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼›3. å‚è§åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ã€‚'},
                           'åŽ‹åŠ›é™åˆ¶': {'åŽŸå› ': 'åŽ‹åŠ›è¾¾åˆ°åŽ‹åŠ›æŠ¥è­¦é«˜é™-5cmH2O', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥å‚æ•°è®¾ç½®ï¼ŒåŒ…æ‹¬åŽ‹åŠ›æŠ¥è­¦é«˜é™è®¾ç½®ï¼›2.æ£€æŸ¥æ˜¯å¦æœ‰åŽ‹åŠ›ä¼ æ„Ÿå™¨æ•…éšœæŠ¥è­¦ï¼ˆå¯¹åº”æŠ¥è­¦å­—ç¬¦ä¸²ä¸ºâ€œæœºå™¨æ•…éšœ 09â€å’Œâ€œæœºå™¨æ•…éšœ 21â€ï¼‰ï¼Œå¦‚æžœæ•…éšœè¯·æ›´æ¢ï¼› 3.å¦‚æžœæ•…éšœä»ç„¶å­˜åœ¨ï¼Œè¯·æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'å®¹é‡é™åˆ¶': {'åŽŸå› ': 'åŽ‹åŠ›æ¨¡å¼ä¸‹ï¼Œé€æ°”è¶…è¿‡è®¾å®šæ½®æ°”é‡ä¸Šé™ï¼Œæå‰è½¬ä¸ºå‘¼æ°”', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥å‚æ•°è®¾ç½®ï¼ŒåŒ…æ‹¬å‘¼å‡ºæ½®æ°”é‡æŠ¥è­¦é«˜é™è®¾ç½®ï¼› 2.æ£€æŸ¥æ˜¯å¦æœ‰â€œè¯·æ£€æŸ¥å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨â€æŠ¥è­¦ï¼Œå¦‚æžœæœ‰è¯¥æŠ¥è­¦ï¼Œè¯·å…ˆæŽ’é™¤è¯¥æŠ¥è­¦ï¼›3.å¦‚æžœæ•…éšœä»ç„¶å­˜åœ¨ï¼Œè¯·æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'å¸æ°”åŽ‹åŠ›æœªè¾¾åˆ°': {'åŽŸå› ': 'æ°”é“å³°åŽ‹æ²¡æœ‰è¾¾åˆ°è®¾å®šå€¼', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ç®¡é“æ˜¯å¦æ³„æ¼ï¼Œå¦‚æžœæœ‰ï¼Œè¯·é‡æ–°è¿žæŽ¥ï¼› 2. å‚è§åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼› 3.æ£€æŸ¥å‚æ•°è®¾ç½®ã€‚ '},
                           'å‘¼å‡ºæ½®æ°”é‡è¿‡ä½Ž': {'åŽŸå› ': 'æ½®æ°”é‡æ²¡æœ‰è¾¾åˆ°è®¾å®šå€¼','è§£å†³æ–¹æ³•': '1.æ£€æŸ¥ç®¡é“æ˜¯å¦æ³„æ¼ï¼Œå¦‚æžœæœ‰ï¼Œè¯·é‡æ–°è¿žæŽ¥ï¼›2. å‚è§æµé‡ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥æµé‡ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼›3.æ£€æŸ¥å‚æ•°è®¾ç½®æ˜¯å¦åˆç†ã€‚ '},
                           'æ½®æ°”é‡æœªè¾¾åˆ°': {'åŽŸå› ': 'æ½®æ°”é‡æ²¡æœ‰è¾¾åˆ°è®¾å®šå€¼','è§£å†³æ–¹æ³•': '1.æ£€æŸ¥ç®¡é“æ˜¯å¦æ³„æ¼ï¼Œå¦‚æžœæœ‰ï¼Œè¯·é‡æ–°è¿žæŽ¥ï¼›2. å‚è§æµé‡ä¼ æ„Ÿå™¨æµ‹é‡å‡†ç¡®æ€§çš„æ£€æµ‹ç« èŠ‚ï¼Œæ£€æŸ¥æµé‡ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸å‡†ï¼Œè¯·é‡æ–°æ ¡å‡†ï¼›3.æ£€æŸ¥å‚æ•°è®¾ç½®æ˜¯å¦åˆç†ã€‚ '},
                           'å¹æ¯å‘¨æœŸåŽ‹åŠ›é™åˆ¶': {'åŽŸå› ': 'å¹æ¯åŠŸèƒ½å¯åŠ¨åŽï¼Œå¹æ¯å‘¨æœŸçš„åŽ‹åŠ›è¾¾åˆ°åŽ‹åŠ›æŠ¥è­¦é«˜é™-5cmH2O', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥å‚æ•°è®¾ç½®ï¼ŒåŒ…æ‹¬åŽ‹åŠ›æŠ¥è­¦é«˜é™è®¾ç½®ï¼›2.æ£€æŸ¥æ˜¯å¦æœ‰åŽ‹åŠ›ä¼ æ„Ÿå™¨æ•…éšœæŠ¥è­¦ï¼ˆå¯¹åº”æŠ¥è­¦å­—ç¬¦ä¸²ä¸ºâ€œæœºå™¨æ•…éšœ 09â€å’Œâ€œæœºå™¨æ•…éšœ 21â€ï¼‰ï¼Œå¦‚æžœæ•…éšœè¯·æ›´æ¢ï¼› 3.å¦‚æžœæ•…éšœä»ç„¶å­˜åœ¨ï¼Œè¯·æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'æ°§æ°”ä¸è¶³': {'åŽŸå› ':'æ°§æ°”ä¾›åº”ä¸å……è¶³', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æ˜¯å¦è¿žæŽ¥é«˜åŽ‹æ°§æ°”æºï¼Œä¸”æ°”æºæ˜¯å¦å……è¶³ï¼› 2.åœ¨é˜€é—¨è¯Šæ–­ç•Œé¢è¯Šæ–­æ°§æ°”æ¯”ä¾‹é˜€æ˜¯å¦å¼‚å¸¸ï¼ˆå‚è§å¸æ°”é˜€æˆ–æ°§æ°”æ¯”ä¾‹é˜€çŠ¶æ€å¼‚å¸¸è¯Šæ–­ï¼‰ï¼Œå¦‚æžœå¼‚å¸¸æ›´æ¢æ°§æ°”æ¯”ä¾‹é˜€3.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'å¸æ°”æ—¶é—´è¿‡é•¿': {'åŽŸå› ':'PSV æ¨¡å¼è‡ªä¸»å‘¼å¸ä¸€ç›´ä¸æ»¡è¶³å‘¼æ°”çµæ•åº¦è€Œä½¿å¾—å¸æ°”è¿‡ç¨‹ä¸èƒ½ç»“æŸã€‚', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥å‚æ•°è®¾ç½®ï¼›2.æ£€æŸ¥å¹¶æ›´æ¢åŽ‹åŠ›å’Œæµé‡ä¼ æ„Ÿå™¨ã€‚'},
                           'å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨æ•…éšœ': {'åŽŸå› ':'å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨æ•…éšœ','è§£å†³åŠžæ³•':'1.æ ¡é›¶ï¼Œå‚è§åŽ‹åŠ›å’Œæµé‡æ ¡é›¶ï¼› 2.æ ¡å‡†å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨ï¼Œå‚è§æµé‡æ ¡å‡†ï¼› 3.æ›´æ¢å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨ã€‚ '},
                           'å¸å…¥æ°”ä½“æ¸©åº¦è¿‡é«˜': {'åŽŸå› ':'å¸å…¥æ°”ä½“æ¸©åº¦è¶…è¿‡é™åˆ¶','è§£å†³åŠžæ³•':'1.æ£€æŸ¥æœºå™¨å·¥ä½œçŽ¯å¢ƒæ¸©åº¦æ˜¯å¦è¶…è¿‡åŽ‚å®¶å£°ç§°æœ€å¤§å·¥ä½œæ¸©åº¦ 40â„ƒï¼› 2.æ£€æŸ¥é£Žæ‰‡å…¥å£ã€å‡ºé£Žå£æ˜¯å¦è¢«å µï¼Œå¦‚æžœè¢«å µï¼Œæ¸…ç†å¼‚ç‰©å’Œç°å°˜ï¼›æ£€æŸ¥é£Žæ‰‡è¿è½¬æƒ…å†µï¼Œå¦‚æžœå¼‚å¸¸ï¼ˆå¦‚å¼‚å“ã€è½¬é€Ÿä¸æ­£å¸¸ç­‰ï¼‰ï¼Œåˆ™æ›´æ¢é£Žæ‰‡ï¼› 3.åœ¨ A/D é€šé“ä¸­ï¼Œæ£€æŸ¥å¸å…¥æ··åˆæ°”ä½“å’Œå¸å…¥æ°§æ°”çš„æ¸©åº¦æµ‹é‡å€¼æ˜¯å¦è¶…å‡º A/D é€šé“æä¾›çš„èŒƒå›´ï¼Œæ›´æ¢å¯¹åº”æ¸©åº¦è¶…é™çš„æµé‡ä¼ æ„Ÿå™¨ï¼ˆæ··åˆæ°”ä½“æµé‡ä¼ æ„Ÿå™¨æˆ–æ°§æ°”æµé‡ä¼ æ„Ÿå™¨ï¼‰'},
                           'æ°§ä¼ æ„Ÿå™¨æœªè¿žæŽ¥': {'åŽŸå› ':'æ²¡æœ‰è¿žæŽ¥æ°§ä¼ æ„Ÿå™¨', 'è§£å†³åŠžæ³•':'1.æ£€æŸ¥æ°§ä¼ æ„Ÿå™¨ç”µç¼†æ˜¯å¦è„±è½ï¼Œå¦‚æžœè„±è½ï¼Œè¯·é‡æ–°è¿žæŽ¥ã€‚2.å¦‚æžœæ•…éšœä»ç„¶å­˜åœ¨ï¼Œæ›´æ¢æ°§ä¼ æ„Ÿå™¨ã€‚'},
                           'è¯·æ›´æ¢æ°§ä¼ æ„Ÿå™¨': {'åŽŸå› ':'æ°§ä¼ æ„Ÿå™¨ç”¨å°½', 'è§£å†³åŠžæ³•':'æ›´æ¢æ°§ä¼ æ„Ÿå™¨'},
                           'è¯·æ ¡å‡†æ°§ä¼ æ„Ÿå™¨': {'åŽŸå› ':'æ°§ä¼ æ„Ÿå™¨æœªè¿›è¡Œæ ¡å‡†','è§£å†³åŠžæ³•':'é‡æ–°è¿›è¡Œ21%å’Œ100%æ°§ä¼ æ„Ÿå™¨æ ¡å‡†ï¼Œå‚è§O2%æ ¡å‡†'},
                           'è¯·è¿›è¡ŒåŽ‹åŠ›æ ¡å‡†': {'åŽŸå› ': 'åŽ‹åŠ›ä¼ æ„Ÿå™¨æ²¡æœ‰è¿›è¡Œæ ¡å‡†','è§£å†³åŠžæ³•': '1.è¿›è¡ŒåŽ‹åŠ›ä¼ æ„Ÿå™¨æ ¡å‡†ï¼Œå‚è§åŽ‹åŠ›æ ¡å‡†ï¼ˆåŽ‚å®¶ï¼‰ã€‚2.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'è¯·è¿›è¡Œæµé‡æ ¡å‡†': {'åŽŸå› ': 'æµé‡ä¼ æ„Ÿå™¨å’Œå¸æ°”é˜€æ²¡æœ‰è¿›è¡Œæ ¡å‡†', 'è§£å†³åŠžæ³•': '1.è¿›è¡Œæµé‡ä¼ æ„Ÿå™¨å’Œå¸æ°”é˜€æ ¡å‡†ï¼Œå‚è§æµé‡æ ¡å‡†ï¼ˆåŽ‚å®¶ï¼‰ç« èŠ‚ã€‚2.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'æµé‡ä¼ æ„Ÿå™¨ç±»åž‹é”™è¯¯': {'åŽŸå› ': 'ç©ºæ°”æµé‡ä¼ æ„Ÿå™¨æˆ–æ°§æ°”æµé‡ä¼ æ„Ÿå™¨ç±»åž‹é”™', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æ··åˆæ°”ä½“æµé‡ä¼ æ„Ÿå™¨æ˜¯å¦æ˜¯ç©ºæ°”æµé‡ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸æ˜¯ï¼Œè¯·æ›´æ¢ã€‚ 2.æ£€æŸ¥æ°§æ°”æ”¯è·¯æµé‡ä¼ æ„Ÿå™¨æ˜¯å¦æ˜¯æ°§æ°”æµé‡ä¼ æ„Ÿå™¨ï¼Œå¦‚æžœä¸æ˜¯ï¼Œè¯·æ›´æ¢ã€‚ '},
                           'æ¶¡è½®æ¸©åº¦è¿‡é«˜': {'åŽŸå› ': 'æ¶¡è½®æ¸©åº¦è¶…è¿‡ä¸€å®šé˜ˆå€¼', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æœºå™¨å·¥ä½œçŽ¯å¢ƒæ¸©åº¦æ˜¯å¦è¶…è¿‡åŽ‚å®¶å£°ç§°æœ€å¤§å·¥ä½œæ¸©åº¦40â„ƒã€‚2.æ£€æŸ¥é£Žæ‰‡å…¥å£ã€å‡ºé£Žå£æ˜¯å¦è¢«å µï¼Œå¦‚æžœè¢«å µï¼Œæ¸…ç†å¼‚ç‰©å’Œç°å°˜ï¼›æ£€æŸ¥é£Žæ‰‡è¿è½¬æƒ…å†µï¼Œå¦‚æžœå¼‚å¸¸ï¼ˆå¦‚å¼‚å“ã€è½¬é€Ÿä¸æ­£å¸¸ç­‰ï¼‰ï¼Œåˆ™æ›´æ¢é£Žæ‰‡ã€‚'},
                           'ç”µæ± æ¸©åº¦è¿‡é«˜': {'åŽŸå› ':'ç”µæ± æ”¾ç”µè¿‡ç¨‹ä¸­æ¸©åº¦åé«˜', 'è§£å†³åŠžæ³•': '1.ç¡®è®¤ä½¿ç”¨çŽ¯å¢ƒæ¸©åº¦æ˜¯å¦è¿‡é«˜ï¼Œæ¯”å¦‚è¶…è¿‡ 35â„ƒï¼Œå¦‚æžœè¶…è¿‡ï¼Œåˆ™å»ºè®®å®¢æˆ·åœ¨æ›´ä½Žçš„çŽ¯ å¢ƒæ¸©åº¦ä¸­ä½¿ç”¨ï¼Œå¹¶ä¿è¯æœºå™¨é™„è¿‘æ²¡æœ‰å‘çƒ­æºï¼› 2.æ£€æŸ¥é£Žæ‰‡å…¥å£ã€å‡ºé£Žå£æ˜¯å¦è¢«å µï¼Œå¦‚æžœè¢«å µï¼Œæ¸…ç†å¼‚ç‰©å’Œç°å°˜ï¼›æ£€æŸ¥é£Žæ‰‡è¿è½¬æƒ…å†µï¼Œ å¦‚æžœå¼‚å¸¸ï¼ˆå¦‚å¼‚å“ã€è½¬é€Ÿä¸æ­£å¸¸ç­‰ï¼‰ï¼Œåˆ™æ›´æ¢é£Žæ‰‡ï¼›3.è‹¥ä»¥ä¸Š2æ¡å‡æŽ’é™¤ï¼Œåˆ™æ£€æŸ¥ç”µæ± æ˜¯å¦æ­£å¸¸4.æ•…éšœä»ç„¶å­˜åœ¨ï¼Œè¯·æ›´æ¢ DC-DC æ¿'},
                           'æŠ€æœ¯é”™è¯¯01': {'åŽŸå› ': 'æŒ‰é”®æ¿é€šè®¯åœæ­¢', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æŒ‰é”®æ¿å’Œä¸»æŽ§æ¿æŽ¥å£æ˜¯å¦æŽ¥è§¦ä¸è‰¯ï¼Œå¦‚æžœæ˜¯ï¼Œè¯·é‡æ–°æ‹”æ’æˆ–è€…æ›´æ¢é€šè®¯çº¿ã€‚2.æ•…éšœä»å­˜åœ¨ï¼Œæ£€æŸ¥æŒ‰é”®æ¿è½¯ä»¶çš„æ­£ç¡®æ€§ã€‚3.æ•…éšœä»å­˜åœ¨ï¼Œæ›´æ¢æŒ‰é”®æ¿æ¿å¡ã€‚4.æ•…éšœä»å­˜åœ¨ï¼Œæ›´æ¢ä¸»æŽ§æ¿æ¿å¡'},
                           'æŠ€æœ¯é”™è¯¯02': {'åŽŸå› ': 'æŒ‰é”®æ¿è‡ªæ£€é”™è¯¯', 'è§£å†³åŠžæ³•': '1.é‡å¯æœºå™¨ã€‚2.æ›´æ¢æŒ‰é”®æ¿è½¯ä»¶ã€‚3.å¦‚æžœæ•…éšœä¸èƒ½è§£å†³ï¼Œæ›´æ¢æŒ‰é”®æ¿'},
                           'æŠ€æœ¯é”™è¯¯03': {'åŽŸå› ':'æ¶¡è½®æ¸©åº¦ä¼ æ„Ÿå™¨æ•…éšœ', 'è§£å†³åŠžæ³•': 'åœ¨A/Dé€šé“æŸ¥çœ‹æ¶¡è½®å†…éƒ¨æ¸©åº¦å’Œæ¶¡è½®å¤–éƒ¨æ¸©åº¦ï¼Œå¦‚æžœå†…éƒ¨æ¸©åº¦ï¼ˆæˆ–å¤–éƒ¨æ¸©åº¦ï¼‰è¶…é™ï¼Œæ›´æ¢è¯¥æ¸©åº¦ä¼ æ„Ÿå™¨ã€‚'},
                           'æŠ€æœ¯é”™è¯¯05': {'åŽŸå› ': 'çŽ¯å¢ƒå¤§æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨æ•…éšœ', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æ˜¯å¦åŒæ—¶å­˜åœ¨â€œæŠ€æœ¯é”™è¯¯ 06â€æŠ¥è­¦ï¼Œå¦‚æžœå­˜åœ¨ï¼Œåœ¨ A/D é€šé“æŸ¥çœ‹â€œPfilter åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡åŽ‹åŠ›å€¼â€å’Œâ€œå¤§æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å¤§æ°”åŽ‹â€å“ªä¸ªæ•°å€¼æ›´æŽ¥è¿‘å½“å‰çŽ¯å¢ƒå¤§æ°”åŽ‹ï¼Œæ›´æ¢åå·®è¾ƒå¤§çš„ä¼ æ„Ÿå™¨ã€‚2.æ›´æ¢ç›‘æŽ§æ¿'},
                           'æŠ€æœ¯é”™è¯¯06': {'åŽŸå› ': 'HEPA è¿‡æ»¤å™¨åŽ‹åŠ›ä¼ æ„Ÿå™¨æ•…éšœ', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æ˜¯å¦åŒæ—¶å­˜åœ¨â€œæŠ€æœ¯é”™è¯¯ 05â€æŠ¥è­¦ï¼Œå¦‚æžœå­˜åœ¨ï¼Œåœ¨ A/D é€šé“æŸ¥çœ‹â€œPfilter åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡åŽ‹åŠ›å€¼â€å’Œâ€œå¤§æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨æµ‹é‡å¤§æ°”åŽ‹â€å“ªä¸ªæ•°å€¼æ›´æŽ¥è¿‘å½“å‰çŽ¯å¢ƒå¤§æ°”åŽ‹ï¼Œæ›´æ¢åå·®è¾ƒå¤§çš„ä¼ æ„Ÿå™¨ï¼›2.æ›´æ¢ç›‘æŽ§æ¿'},
                           'æŠ€æœ¯é”™è¯¯07': {'åŽŸå› ': 'ä¸‰é€šé˜€æ•…éšœ', 'è§£å†³åŠžæ³•': 'æ£€æŸ¥ä¸‰é€šé˜€ï¼Œå¹¶æ›´æ¢'},
                           'æŠ€æœ¯é”™è¯¯08': {'åŽŸå› ': 'é›¾åŒ–é˜€æ•…éšœ', 'è§£å†³åŠžæ³•': 'æ£€æŸ¥é›¾åŒ–é˜€ï¼Œå¹¶æ›´æ¢'},
                           'æŠ€æœ¯é”™è¯¯09': {'åŽŸå› ': 'å¸å…¥æ¸©åº¦ä¼ æ„Ÿå™¨æ•…éšœ', 'è§£å†³åŠžæ³•': '1.åœ¨ A/D é€šé“ä¸­ï¼Œæ£€æŸ¥å¸å…¥æ··åˆæ°”ä½“å’Œå¸å…¥æ°§æ°”çš„æ¸©åº¦æµ‹é‡å€¼æ˜¯è¿‡å¤§æˆ–è¿‡å°ï¼Œæ›´æ¢å­˜åœ¨é—®é¢˜çš„æ¸©åº¦ä¼ æ„Ÿå™¨ï¼›2. æ›´æ¢å¸å…¥æ··åˆæ°”ä½“æ¸©åº¦ä¼ æ„Ÿå™¨å’Œå¸å…¥æ°§æ°”æ¸©åº¦ä¼ æ„Ÿå™¨'},
                           'æœºå™¨æ•…éšœ01': {'åŽŸå› ': 'æœºå™¨å†…éƒ¨ç”µåŽ‹å¼‚å¸¸', 'è§£å†³åŠžæ³•': '1.æµ‹é‡ç›¸åº”æµ‹è¯•ç‚¹ç”µåŽ‹ï¼›2.æ•…éšœä»ç„¶å­˜åœ¨æ›´æ¢ç”µæºæ¿'},
                           'æœºå™¨æ•…éšœ02': {'åŽŸå› ': 'å†…å­˜å¼‚å¸¸', 'è§£å†³åŠžæ³•': '1.é‡å¯å‘¼å¸æœºï¼›2.æ•…éšœä»ç„¶å­˜åœ¨æ›´æ¢ç›‘æŽ§æ¿'},
                           'æœºå™¨æ•…éšœ03': {'åŽŸå› ': 'ç”µæºæ¿è‡ªæ£€é”™è¯¯', 'è§£å†³åŠžæ³•': '1.é‡å¯å‘¼å¸æœºï¼›2.æ›´æ¢ç”µæºæ¿è½¯ä»¶ï¼›3.å¦‚æžœæ•…éšœä¸èƒ½è§£å†³ï¼Œæ›´æ¢ç”µæºæ¿'},
                           'æœºå™¨æ•…éšœ04': {'åŽŸå› ': 'ç›‘æŽ§æ¨¡å—åˆå§‹åŒ–é”™è¯¯', 'è§£å†³åŠžæ³•': 'æ£€æŸ¥ç›‘æŽ§æ¿ç¡¬ä»¶ï¼Œå¦‚æžœæ•…éšœè¯·æ›´æ¢'},
                           'æœºå™¨æ•…éšœ05': {'åŽŸå› ': 'ç›‘æŽ§æ¨¡å—é€šè®¯åœæ­¢', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ç›‘æŽ§æ¿å’Œä¸»æŽ§æ¿æŽ¥å£æ˜¯å¦æŽ¥è§¦ä¸è‰¯ï¼Œå¦‚æžœæ˜¯ï¼Œè¯·é‡æ–°æ‹”æ’æˆ–è€…æ›´æ¢é€šè®¯çº¿ï¼›2.æ£€æŸ¥ç›‘æŽ§æ¨¡å—æ˜¯å¦æŸåï¼Œå¦‚æžœæŸåï¼Œè¯·æ›´æ¢ç›‘æŽ§æ¨¡å—ï¼›3.æ£€æŸ¥ä¸»æŽ§æ¿æ˜¯å¦æŸåï¼Œå¦‚æžœæŸåï¼Œè¯·æ›´æ¢ä¸»æŽ§æ¿ï¼›4.æ£€æŸ¥è½¯ä»¶ç‰ˆæœ¬æ˜¯å¦å…¼å®¹ï¼Œè‹¥ä¸å…¼å®¹ï¼Œè¯·é‡æ–°å‡çº§æ­£ç¡®çš„è½¯ä»¶ç‰ˆæœ¬ã€‚'},
                           'æœºå™¨æ•…éšœ06': {'åŽŸå› ': 'ç›‘æŽ§æ¨¡å—è‡ªæ£€é”™è¯¯', 'è§£å†³åŠžæ³•': '1.é‡å¯å‘¼å¸æœºï¼›2.æ£€æŸ¥å¹¶æ›´æ¢ç›‘æŽ§æ¨¡å—'},
                           'æœºå™¨æ•…éšœ07': {'åŽŸå› ': 'å¸æ°”æ¨¡å—é€šè®¯åœæ­¢', 'è§£å†³åŠžæ³•': '1.é‡å¯å‘¼å¸æœºï¼›2.å‡çº§å¸æ°”æ¨¡å—è½¯ä»¶å’Œç›‘æŽ§æ¨¡å—è½¯ä»¶'},
                           'æœºå™¨æ•…éšœ08': {'åŽŸå› ': 'å‘¼æ°”æ¨¡å—é€šè®¯åœæ­¢', 'è§£å†³åŠžæ³•': '1.é‡å¯å‘¼å¸æœºï¼›2.å‡çº§å‘¼æ°”æ¨¡å—è½¯ä»¶å’Œç›‘æŽ§æ¨¡å—è½¯ä»¶'},
                           'æœºå™¨æ•…éšœ09': {'åŽŸå› ': 'åŽ‹åŠ›ä¼ æ„Ÿå™¨é€šè®¯åœæ­¢', 'è§£å†³åŠžæ³•': '1.æ›´æ¢å¸æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨ï¼›2.æ›´æ¢å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨'},
                           'æœºå™¨æ•…éšœ10': {'åŽŸå› ': 'å®‰å…¨é˜€æ•…éšœ', 'è§£å†³åŠžæ³•': 'æ£€æŸ¥å®‰å…¨é˜€ï¼Œå¹¶æ›´æ¢'},
                           'æœºå™¨æ•…éšœ12': {'åŽŸå› ': 'å¸æ°”æ”¯è·¯æ•…éšœ', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥å¸æ°”é˜€æ˜¯å¦å·¥ä½œæ­£å¸¸ï¼Œå¦‚æžœå·¥ä½œä¸æ­£å¸¸ï¼Œè¯·æ›´æ¢å¸æ°”é˜€ï¼›2.æ£€æŸ¥å¸æ°”æµé‡ä¼ æ„Ÿå™¨ï¼›3.æ›´æ¢å¸æ°”é˜€æˆ–è€…å¸æ°”æµé‡ä¼ æ„Ÿå™¨å¹¶æ ¡å‡†'},
                           'æœºå™¨æ•…éšœ13': {'åŽŸå› ': 'O2æ”¯è·¯æ•…éšœ', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æ°§æ°”æ¯”ä¾‹é˜€æ˜¯å¦å·¥ä½œæ­£å¸¸ï¼Œå¦‚æžœå·¥ä½œä¸æ­£å¸¸ï¼Œè¯·æ›´æ¢æ°§æ°”æ¯”ä¾‹é˜€ï¼›2.æ£€æŸ¥æ°§æ°”æµé‡ä¼ æ„Ÿå™¨ï¼›3.æ›´æ¢æ°§æ°”æ¯”ä¾‹é˜€æˆ–è€…æ°§æ°”æµé‡ä¼ æ„Ÿå™¨å¹¶æ ¡å‡†'},
                           'æœºå™¨æ•…éšœ14': {'åŽŸå› ':'æ¶¡è½®å¤±æ•ˆ', 'è§£å†³åŠžæ³•': 'æ›´æ¢æ¶¡è½®'},
                           'æœºå™¨æ•…éšœ15': {'åŽŸå› ': 'æ¶¡è½®æ¸©åº¦è¿‡é«˜', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥æœºå™¨å·¥ä½œçŽ¯å¢ƒæ¸©åº¦æ˜¯å¦è¶…è¿‡å·¥ä½œæ¸©åº¦ï¼›2.æ£€æŸ¥é£Žæ‰‡å…¥å£ã€å‡ºé£Žå£æ˜¯å¦è¢«å µï¼Œå¦‚æžœè¢«å µï¼Œæ¸…ç†å¼‚ç‰©å’Œç°å°˜ï¼›æ£€æŸ¥é£Žæ‰‡è¿è½¬æƒ…å†µï¼Œå¦‚æžœå¼‚å¸¸ï¼ˆå¦‚å¼‚å“ã€è½¬é€Ÿä¸æ­£å¸¸ç­‰ï¼‰ï¼Œåˆ™æ›´æ¢é£Žæ‰‡'},
                           'æœºå™¨æ•…éšœ16': {'åŽŸå› ': 'å¸æ°”é˜€è„±è½', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥å¸æ°”é˜€è¿žæŽ¥æƒ…å†µï¼›2.æ›´æ¢å¸æ°”é˜€ã€‚'},
                           'æœºå™¨æ•…éšœ17': {'åŽŸå› ': 'å¸æ°”æ¨¡å—è‡ªæ£€é”™è¯¯', 'è§£å†³åŠžæ³•': '1.é‡å¯å‘¼å¸æœºï¼›2.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'æœºå™¨æ•…éšœ18': {'åŽŸå› ': 'å¸æ°”æ¨¡å—è‡ªæ£€é”™è¯¯', 'è§£å†³åŠžæ³•': '1.é‡å¯å‘¼å¸æœºï¼›2.æ›´æ¢ç›‘æŽ§æ¿ã€‚'},
                           'æœºå™¨æ•…éšœ19': {'åŽŸå› ': 'ç”µæºæ¿é€šè®¯åœæ­¢', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ç”µæºæ¿å’Œä¸»æŽ§æ¿æŽ¥å£æ˜¯å¦æŽ¥è§¦ä¸è‰¯ï¼Œå¦‚æžœæ˜¯ï¼Œè¯·é‡æ–°æ‹”æ’æˆ–è€…æ›´æ¢é€šè®¯çº¿ï¼›2.æ£€æŸ¥ç”µæºæ¿æ˜¯å¦æŸåï¼Œå¦‚æžœæŸåï¼Œè¯·æ›´æ¢ç”µæºæ¿ï¼›3.æ£€æŸ¥ä¸»æŽ§æ¿æ˜¯å¦æŸåï¼Œå¦‚æžœæŸåï¼Œè¯·æ›´æ¢ä¸»æŽ§æ¿ï¼›4.æ£€æŸ¥è½¯ä»¶ç‰ˆæœ¬æ˜¯å¦å…¼å®¹ï¼Œè‹¥ä¸å…¼å®¹ï¼Œè¯·é‡æ–°å‡çº§æ­£ç¡®çš„è½¯ä»¶ç‰ˆæœ¬'},
                           'æœºå™¨æ•…éšœ21': {'åŽŸå› ': 'åŽ‹åŠ›ä¼ æ„Ÿå™¨é›¶ç‚¹é”™è¯¯', 'è§£å†³åŠžæ³•': '1.æ›´æ¢å¸æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨ã€‚2.æ›´æ¢å‘¼æ°”åŽ‹åŠ›ä¼ æ„Ÿå™¨'},
                           'æœºå™¨æ•…éšœ22': {'åŽŸå› ': 'ä¿æŠ¤æ¨¡å—é€šè®¯åœæ­¢', 'è§£å†³åŠžæ³•': '1.æ£€æŸ¥ä¸»æŽ§æ¿æ˜¯å¦æŸåï¼Œå¦‚æžœæŸåï¼Œè¯·æ›´æ¢ä¸»æŽ§æ¿ï¼›2.æ£€æŸ¥è½¯ä»¶ç‰ˆæœ¬æ˜¯å¦å…¼å®¹ï¼Œè‹¥ä¸å…¼å®¹ï¼Œè¯·é‡æ–°å‡çº§æ­£ç¡®çš„è½¯ä»¶ç‰ˆæœ¬'},
                           'ç”µæºæ¿æŠ€æœ¯æŠ¥è­¦': {'åŽŸå› ':'1.ç”µæ± 1å‘ç”Ÿæ•…éšœç±»æŠ¥è­¦;2.ç”µæ± 2å‘ç”Ÿæ•…éšœç±»æŠ¥è­¦', 'è§£å†³åŠžæ³•': '1.æ›´æ¢ç”µæ± 1;2.æ›´æ¢ç”µæ± 2'},
                           'ç”µæ± 1æ•…éšœ01':{'åŽŸå› ':'ç”µæ± 1æ¸©åº¦å¼‚å¸¸ï¼Œä¸èƒ½å……ç”µ;','è§£å†³åŠžæ³•':'æ›´æ¢ç”µæ± 1'},
                           'ç”µæ± 1æ•…éšœ02': {'åŽŸå› ': 'ç”µæ± 1å……ç”µæ•…éšœ', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 1'},
                           'ç”µæ± 1æ•…éšœ03': {'åŽŸå› ': 'ç”µæ± 1è€åŒ–', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 1'},
                           'ç”µæ± 1æ•…éšœ04': {'åŽŸå› ': 'ç”µæ± 1é€šè®¯å¼‚å¸¸', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 1'},
                           'ç”µæ± 1æ•…éšœ05': {'åŽŸå› ': 'ç”µæ± 1æ•…éšœ', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 1'},
                           'ç”µæ± 2æ•…éšœ01':{'åŽŸå› ':  'ç”µæ± 2æ¸©åº¦å¼‚å¸¸ï¼Œä¸èƒ½å……ç”µ;','è§£å†³åŠžæ³•':'æ›´æ¢ç”µæ± 2'},
                           'ç”µæ± 2æ•…éšœ02': {'åŽŸå› ': 'ç”µæ± 2å……ç”µæ•…éšœ', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 2'},
                           'ç”µæ± 2æ•…éšœ03': {'åŽŸå› ': 'ç”µæ± 2è€åŒ–', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 2'},
                           'ç”µæ± 2æ•…éšœ04': {'åŽŸå› ': 'ç”µæ± 2é€šè®¯å¼‚å¸¸', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 2'},
                           'ç”µæ± 2æ•…éšœ05': {'åŽŸå› ': 'ç”µæ± 2æ•…éšœ', 'è§£å†³åŠžæ³•': 'æ›´æ¢ç”µæ± 2'},
                           'C02æ¨¡å—æ•…éšœ': {'åŽŸå› ': '1:CO2æ ¡é›¶å¤±è´¥;2:CO2åˆå§‹åŒ–é”™è¯¯;3:CO2è‡ªæ£€é”™è¯¯;4:CO2ç¡¬ä»¶é”™è¯¯;5:CO2é€šè®¯åœæ­¢;6:CO2æ ¡é›¶é”™è¯¯', 'è§£å†³åŠžæ³•':'1.1æ£€æŸ¥CO2ä¼ æ„Ÿå™¨ç®¡è·¯è¿žæŽ¥æ˜¯å¦æ­£å¸¸ï¼Œé‡æ–°æ ¡é›¶ï¼›1.2å¦‚æžœä»ç„¶å‡ºçŽ°é—®é¢˜ï¼Œè¯·æ›´æ¢ CO2 æ¨¡å—ã€‚2.1é‡æ–°æ’æ‹” CO2 æ¨¡å—ï¼›2.2æ›´æ¢ CO2 æ¨¡å—ã€‚3.1é‡æ–°æ’æ‹” CO2 æ¨¡å—ï¼›3.2æ›´æ¢CO2æ¨¡å—ã€‚4.1æ£€æŸ¥ä¼ æ„Ÿå™¨æ˜¯å¦æ­£ç¡®è¿žæŽ¥ï¼›4.2å¦‚æžœè¿žæŽ¥æ­£ç¡®ï¼Œä»ç„¶å‡ºçŽ°è¯¥æŠ¥è­¦ï¼Œè¯·æ›´æ¢CO2æ¨¡å—ã€‚5.1æ£€æŸ¥CO2ä¸Žä¸»æŽ§æ¿è¿žæŽ¥çº¿æ˜¯å¦æœ‰é—®é¢˜ï¼Œå¦‚æžœæ˜¯è¯·é‡æ–°æ’æ‹”æˆ–æ›´æ¢é€šè®¯çº¿ï¼›5.2æ£€æŸ¥CO2ä¸Žä¸»æŽ§æ¿æ˜¯å¦æœ‰æŸåï¼Œå¦‚æžœæŸåè¯·æ›´æ¢ã€‚6.1æŒ‰ç…§ä¸»æµCO2æ ¡é›¶çš„æç¤ºï¼Œæ£€æŸ¥æ ¡é›¶æ–¹æ³•æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æžœæœ‰è¯¯ï¼Œè¯·æŒ‰ç…§æ­£ç¡®çš„æ–¹æ³•é‡æ–°æ ¡é›¶ï¼›6.2æ£€æŸ¥ä¸»æµ CO2 æ˜¯å¦æœ‰æŸåï¼Œå¦‚æžœæŸåï¼Œè¯·æ›´æ¢ã€‚'},
                           'C02é€šè®¯é”™è¯¯': {'åŽŸå› ': '1.CO2 æ¨¡å—é€šè®¯çº¿æŽ¥è§¦ä¸å¥½ï¼›2.CO2 æ¨¡å—æœ‰é—®é¢˜ã€‚', 'è§£å†³æ–¹æ³•': '1.æ£€æŸ¥ã€é‡æ–°æ’æ‹” CO2 æ¨¡å—é€šè®¯çº¿ï¼›2.æ›´æ¢ CO2 æ¨¡å—ã€‚'},
                           'åˆ†é’Ÿé€šæ°”é‡è¿‡ä½Ž':{'åŽŸå› ': 'æ½®æ°”å€¼æ²¡æœ‰è¾¾åˆ°è®¾å®šå€¼','è§£å†³æ–¹æ³•': 'æ£€æŸ¥ç®¡é“æ˜¯å¦æ˜¯å¦æ³„éœ²'},
                           'å®¤æƒ ':{'åŽŸå› ': 'æ½®æ°”å€¼æ²¡æœ‰è¾¾åˆ°è®¾å®šå€¼','è§£å†³æ–¹æ³•': 'æ£€æŸ¥ç®¡é“æ˜¯å¦æ˜¯å¦æ³„éœ²'},
                           'ç”µæ± æœªå‘çŽ°':{'åŽŸå› ': 'æ²¡æœ‰æ£€æµ‹åˆ°ç”µæ± ','è§£å†³æ–¹æ³•': 'æ£€æŸ¥ç”µæ± æ˜¯å¦å®‰è£…'},
                           'None':{'åŽŸå› ':'None','è§£å†³æ–¹æ³•':'None'}}#ç§‘æ›¼æ•°æ®
            mindray_fault = {}#è¿ˆå‡¯ç‘žæ•°æ®comen_faut mindray_fault
            aeonmed_fault ={'æ°”é“åŽ‹åŠ›é«˜': {'åŽŸå› ï¼ˆä½Žçº§ï¼‰': 'æ°”é“åŽ‹åŠ›åœ¨ä¸€ä¸ªå‘¼å¸å‘¨æœŸå†…é«˜äºŽè®¾å®šå€¼ã€‚', 'è§£å†³åŠžæ³•ï¼ˆä½Žçº§ï¼‰': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–è€…æŒç»­15ç§’æ°”é“åŽ‹åŠ›ä½ŽäºŽè®¾å®šé™å€¼',
                                         'åŽŸå› ï¼ˆçº¢è‰²é«˜çº§ï¼‰': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæ°”é“åŽ‹åŠ›ä½ŽäºŽè®¾å®šé™å€¼ã€‚', 'è§£å†³åŠžæ³•ï¼ˆçº¢è‰²é«˜çº§ï¼‰': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–è€…æŒç»­15ç§’æ°”é“åŽ‹åŠ›é«˜äºŽè®¾å®šé™å€¼'},
                            'æ³„æ¼': {'åŽŸå› ': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–10ç§’ç›‘æµ‹çš„åˆ†é’Ÿæ¼æ°”é‡é«˜äºŽç›‘æµ‹çš„åˆ†é’Ÿé€šæ°”é‡', 'è§£å†³åŠžæ³•': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–10ç§’ç›‘æµ‹çš„åˆ†é’Ÿæ¼æ°”é‡åœ¨æ­£å¸¸èŒƒå›´'},
                            'æ°§æ°”ä¸è¶³': {'åŽŸå› ï¼ˆä½Žçº§ï¼‰': 'æ°§æ°”æ°”æºåŽ‹åŠ›ä½ŽäºŽ160KPaï¼Œä¸”æ°§æ°”æµ“åº¦è®¾ä¸º21%', 'è§£å†³åŠžæ³•ï¼ˆä½Žçº§ï¼‰': 'æ°§æ°”æ°”æºåŽ‹åŠ›è®¾ä¸º160KPa',
                                        'åŽŸå› ï¼ˆçº¢è‰²é«˜çº§ï¼‰': 'æ°§æ°”æ°”æºåŽ‹åŠ›ä½ŽäºŽ160KPa%', 'è§£å†³åŠžæ³•ï¼ˆçº¢è‰²é«˜çº§ï¼‰': 'æ°§æ°”æ°”æºåŽ‹åŠ›é«˜äºŽ160KPa',},
                            'äº¤æµç”µæ•…éšœ': {'åŽŸå› ': 'å‘ç”Ÿäº¤æµç”µæ•…éšœä¸”æ²¡æœ‰ç”µæ± ä¾›ç”µï¼Œç”µè·¯æ¿å‘å‡ºè‡³å°‘120ç§’æŠ¥è­¦ï¼›æœ‰ç”µæ± ä¾›ç”µæ—¶å‡ºçŽ°â€˜äº¤æµç”µæ•…éšœâ€™æŠ¥è­¦ã€‚', 'è§£å†³åŠžæ³•': 'é‡æ–°è¿žæŽ¥äº¤æµç”µ'},
                            'é›¾åŒ–': {'åŽŸå› ': 'å¼€å§‹é›¾åŒ–æ“ä½œã€‚', 'è§£å†³åŠžæ³•': 'é›¾åŒ–æ“ä½œå®Œæˆæˆ–ä¸­æ–­'},
                            'è‚ºå¤å¼ ': {'åŽŸå› ': 'å¼€å§‹è‚ºå¤å¼ æ“ä½œã€‚', 'è§£å†³åŠžæ³•': 'è‚ºå¤å¼ æ“ä½œå®Œæˆæˆ–ä¸­æ–­'},
                            'å†…éƒ¨ç”µæ± éœ€è¦æ ¡éªŒ': {'åŽŸå› ': 'å†…éƒ¨ç”µæ± éœ€è¦æ ¡éªŒã€‚', 'è§£å†³åŠžæ³•': 'æ ¡éªŒå†…éƒ¨ç”µæ± ï¼Œé‡å¯å‘¼å¸æœº'},
                            'å¤‡ç”¨ç”µæ± éœ€è¦æ ¡éªŒ': {'åŽŸå› ': 'å¤‡ç”¨ç”µæ± éœ€è¦æ ¡éªŒã€‚', 'è§£å†³åŠžæ³•': 'æ ¡éªŒå¤‡ç”¨ç”µæ± ï¼Œé‡å¯å‘¼å¸æœº'},
                            'å‘¼æ°”ä¿æŒä¸­æ–­': {'åŽŸå› ': 'å‘¼æ°”ä¿æŒå€’è®¡æ—¶ç»“æŸåŽï¼Œè¿˜æœªæ¾å¼€å‘¼æ°”ä¿æŒæŒ‰é’®ã€‚', 'è§£å†³åŠžæ³•': 'æ¾å¼€å‘¼æ°”ä¿æŒæŒ‰é’®'},
                            'å¸æ°”ä¿æŒä¸­æ–­': {'åŽŸå› ': 'å¸æ°”ä¿æŒå€’è®¡æ—¶ç»“æŸåŽï¼Œè¿˜æœªæ¾å¼€å¸æ°”ä¿æŒæŒ‰é’®ã€‚', 'è§£å†³åŠžæ³•': 'æ¾å¼€å¸æ°”ä¿æŒæŒ‰é’®'},
                            'ç”µæ± ç”µé‡ä½Ž': {'åŽŸå› ': 'ç”µæ± ä¾›ç”µæƒ…å†µä¸‹ï¼Œé¢„è®¡æœºå™¨è¿è¡Œæ—¶é—´å°‘äºŽ30åˆ†é’Ÿ', 'è§£å†³åŠžæ³•': 'å¤–æŽ¥äº¤æµç”µ'},
                            'è‡ªä¸»å‘¼å¸é¢‘çŽ‡é«˜': {'åŽŸå› ': 'è¿žç»­4ä¸ªå‘¼å¸å‘¨æœŸæˆ–è€…20ç§’è‡ªä¸»å‘¼å¸é¢‘çŽ‡è¶…è¿‡è®¾ç½®é™å€¼', 'è§£å†³åŠžæ³•': 'è¿žç»­4ä¸ªå‘¼å¸å‘¨æœŸè‡ªä¸»å‘¼å¸é¢‘çŽ‡ä½ŽäºŽè®¾ç½®é™å€¼'},
                            'æ°§æµ“åº¦ä¼ æ„Ÿå™¨ç”µåŽ‹è¿‡ä½Ž': {'åŽŸå› ': 'åœ¨ä½¿ç”¨å‰æµ‹è¯•æœŸé—´æ£€æµ‹', 'è§£å†³åŠžæ³•': 'é‡å¤ä½¿ç”¨å‰æµ‹è¯•ï¼Œæµ‹é‡ä¼ æ„Ÿå™¨ä¿¡å·æ˜¯å¦æ­£å¸¸'},
                            'æ°§æµ“åº¦é«˜': {'åŽŸå› ': 'è¿žç»­30ç§’æ°§æµ“åº¦ç›‘æµ‹å€¼é«˜äºŽè®¾ç½®å€¼6%ä»¥ä¸Šã€‚', 'è§£å†³åŠžæ³•': 'è¿žç»­30ç§’æ°§æµ“åº¦ç›‘æµ‹å€¼ä½ŽäºŽè®¾å®šå€¼6%ä»¥ä¸Š'},
                            'æ°§æµ“åº¦ä½Ž': {'åŽŸå› ': 'è¿žç»­30ç§’æ°§æµ“åº¦ç›‘æµ‹å€¼ä½ŽäºŽè®¾ç½®å€¼6%ä»¥ä¸Šæˆ–è€…18%ä»¥ä¸‹', 'è§£å†³åŠžæ³•': 'è¿žç»­30ç§’æ°§æµ“åº¦ç›‘æµ‹å€¼é«˜äºŽè®¾å®šå€¼6%ä»¥ä¸Šæˆ–è€…18%ä»¥ä¸Š'},
                            'åˆ†é’Ÿé€šæ°”é‡é«˜': {'åŽŸå› ': 'å‘¼å¸1åˆ†é’ŸåŽåˆ†é’Ÿé€šæ°”é‡é«˜äºŽè®¾å®šå€¼ä¸Šé™', 'è§£å†³åŠžæ³•': 'åˆ†é’Ÿé€šæ°”é‡ä½ŽäºŽè®¾å®šé™å€¼15ç§’'},
                            'åˆ†é’Ÿé€šæ°”é‡ä½Ž': {'åŽŸå› ': 'åˆ†é’Ÿé€šæ°”é‡1åˆ†é’Ÿå†…ä½ŽäºŽè®¾å®šä¸‹é™ã€‚', 'è§£å†³åŠžæ³•': 'åˆ†é’Ÿé€šæ°”é‡é«˜äºŽè®¾å®šé™å€¼çš„é€šæ°”é‡15ç§’'},
                            'å¸æ°”æ—¶é—´è¿‡é•¿': {'åŽŸå› ': 'æ— åˆ›-è¿žç»­ä¸‰æ¬¡å¸æ°”æ—¶é—´è¶…è¿‡è®¾ç½®é™å€¼ï¼›æœ‰åˆ›-è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆäººå¸æ°”æ—¶é—´è¶…è¿‡5ç§’ï¼Œå°å„¿è¶…è¿‡2ç§’ã€‚', 'è§£å†³åŠžæ³•': 'è¿žç»­3æ¬¡å¸æ°”æ—¶é—´å°äºŽè®¾å®šé™å€¼ï¼ˆæ— åˆ›ï¼‰æˆ–å›ºå®šé™å€¼ï¼ˆæœ‰åˆ›ï¼‰'},
                            'é›¾åŒ–æ“ä½œä¸­æ–­': {'åŽŸå› ': 'é›¾åŒ–æ“ä½œå› ä¸ºæ¨¡å¼æ”¹å˜è€Œä¸­æ–­', 'è§£å†³åŠžæ³•': 'é›¾åŒ–æ“ä½œç»§ç»­æˆ–è€…é€šè¿‡æŠ¥è­¦é™éŸ³é”®æ¶ˆé™¤'},
                            'å‘¼æ°”æ½®æ°”é‡ä½Ž': {'åŽŸå› ï¼ˆä½Žçº§ï¼‰': 'åœ¨1ä¸ªå‘¼å¸å‘¨æœŸå†…å‘¼æ°”æ½®æ°”é‡ä½ŽäºŽè®¾å®šå€¼ã€‚', 'è§£å†³åŠžæ³•ï¼ˆä½Žçº§ï¼‰': 'åœ¨1ä¸ªå‘¼å¸å‘¨æœŸå†…å‘¼æ°”æ½®æ°”é‡é«˜äºŽè®¾å®šå€¼',
                                           'åŽŸå› ï¼ˆçº¢è‰²é«˜çº§ï¼‰': 'è¿žç»­3ä¸ªå‘¨æœŸæˆ–30ç§’å‘¼æ°”æ½®æ°”é‡å§‹ç»ˆä½ŽäºŽè®¾å®šå€¼ã€‚','è§£å†³åŠžæ³•ï¼ˆçº¢è‰²é«˜çº§ï¼‰':'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–è€…æŒç»­30ç§’å‘¼æ°”æ½®æ°”é‡é«˜äºŽè®¾å®šé™å€¼',},
                            'ç”µæ± ç”µé‡è€—å°½': {'åŽŸå› ': 'ç”µæ± ä¾›ç”µæƒ…å†µä¸‹ï¼Œé¢„è®¡æœºå™¨è¿è¡Œæ—¶é—´å°‘äºŽ10åˆ†é’Ÿã€‚','è§£å†³åŠžæ³•': 'è¿žæŽ¥äº¤æµç”µ'},
                            'å†…éƒ¨é”™è¯¯': {'åŽŸå› ': 'å†…éƒ¨é”™è¯¯ã€‚', 'è§£å†³åŠžæ³•': 'é‡å¯è®¾å¤‡ï¼›å¦‚æžœæŠ¥è­¦å†æ¬¡å‘ç”Ÿåœæ­¢ä½¿ç”¨å‘¼å¸æœºï¼Œè®°å½•ä»£ç å¹¶è”ç³»å”®åŽæœåŠ¡äººå‘˜'},
                            'BDUé€šä¿¡æ•…éšœ': {'åŽŸå› ': 'å‘¼å¸æœºBDUå‡ºçŽ°é€šä¿¡æ•…éšœ', 'è§£å†³åŠžæ³•':'é‡å¯è®¾å¤‡ï¼Œå¦‚æžœå¤šæ¬¡å‘ç”Ÿï¼Œè¯·è”ç³»å”®åŽæœåŠ¡äººå‘˜'},
                            'PSé€šä¿¡æ•…éšœ': {'åŽŸå› ': 'å‘¼å¸æœºPSå‡ºçŽ°é€šä¿¡æ•…éšœ', 'è§£å†³åŠžæ³•':'é‡å¯è®¾å¤‡ï¼Œå¦‚æžœå¤šæ¬¡å‘ç”Ÿï¼Œè¯·è”ç³»å”®åŽæœåŠ¡äººå‘˜'},
                            'å‘¼æ°”é˜€åŠ çƒ­å™¨æ•…éšœ': {'åŽŸå› ': 'ç³»ç»Ÿæ£€æŸ¥å‘¼æ°”é˜€åŠ çƒ­å™¨æ•…éšœ', 'è§£å†³åŠžæ³•':'è”ç³»å”®åŽæœåŠ¡äººå‘˜'},
                            'æ°”é“åŽ‹åŠ›æŒç»­é«˜': {'åŽŸå› ': 'æ°”é“åŽ‹åŠ›æŒç»­15ç§’è¶…è¿‡PEEP15cmH2Oï¼Œå‘¼æ°”é˜€æ‰“å¼€é‡Šæ”¾åŽ‹åŠ›', 'è§£å†³åŠžæ³•':'è¿žç»­5ç§’è¶…å‡ºPEEPå€¼å°äºŽ15cmH2O'},
                            'çª’æ¯': {'åŽŸå› ': 'è¶…è¿‡çª’æ¯æŠ¥è­¦é™å€¼çš„æ—¶é—´å†…ï¼Œæ²¡æœ‰è§¦å‘å‘¼å¸å‘¨æœŸ', 'è§£å†³åŠžæ³•': 'å‚ç…§11.1.3é€€å‡ºå¤‡ä»½é€šæ°”'},
                            'PEEPé«˜': {'åŽŸå› ': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸPEEPå€¼é«˜äºŽè®¾å®šé™å€¼','è§£å†³åŠžæ³•': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–è€…æŒç»­15ç§’PEEPå€¼ä½ŽäºŽè®¾å®šé™å€¼'},
                            'ç®¡è·¯è„±è½': {'åŽŸå› ': 'å‘¼å¸ç®¡è·¯æ–­å¼€', 'è§£å†³åŠžæ³•':'é‡æ–°è¿žæŽ¥å‘¼å¸ç®¡è·¯'},
                            'ç®¡è·¯é˜»å¡ž': {'åŽŸå› ': 'å‘¼å¸ç®¡è·¯è¢«é˜»å¡ž', 'è§£å†³åŠžæ³•': 'è§£é™¤é˜»å¡ž'},
                            'æ³„æ¼è¶…å‡ºèŒƒå›´': {'åŽŸå› ': 'ä»…åœ¨NIVæ¨¡å¼ä¸‹-è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæ³„éœ²è¶…è¿‡æœ€å¤§çš„è¡¥å¿å€¼','è§£å†³åŠžæ³•':'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæ³„éœ²ä½ŽäºŽæœ€å¤§è¡¥å¿é‡'},
                            'æ°”é“åŽ‹åŠ›ä½Ž': {'åŽŸå› ': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæ°”é“åŽ‹åŠ›ä½ŽäºŽè®¾å®šé™å€¼', 'è§£å†³åŠžæ³•': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–è€…æŒç»­15ç§’æ°”é“åŽ‹åŠ›é«˜äºŽè®¾å®šé™å€¼'},
                            'PEEPä½Ž': {'åŽŸå› ': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸPEEPå€¼ä½ŽäºŽè®¾å®šé™å€¼', 'è§£å†³åŠžæ³•': 'è¿žç»­3ä¸ªå‘¼å¸å‘¨æœŸæˆ–è€…æŒç»­15ç§’PEEPå€¼é«˜äºŽè®¾å®šé™å€¼'},
                            'é€šä¿¡æ•…éšœ': {'åŽŸå› ': 'é€šä¿¡æ•…éšœ', 'è§£å†³åŠžæ³•': 'å±å¹•ä¸Žä¸»æœºçš„è¿žæŽ¥çº¿æŽ¥ç´§'},
                            }
            test_texts = []
            final_fault = {}#æœ€ç»ˆè°ƒç”¨æ•°æ®
            for d in reversed(pred_boxes):
                c, conf, id = int(d.cls), float(d.conf) if conf else None, None if d.id is None else int(d.id.item())
                text_num.append(c)
                if c == 5:
                    type_number = 'comen'
                if c == 7:
                    type_number = 'mindray'
                if c == 11:
                    type_number = 'aeonmed'
                    #print('è°Šå®‰')
                if c ==6:#å¼€æœºè‡ªæ£€æŠ¥é”™
                    #print(d.xyxy[0][0].item())
                    set_label =True
                    x1 = int(d.xyxy[0][0].item())
                    y1 = int(d.xyxy[0][1].item())
                    x2 = int(d.xyxy[0][2].item())
                    y2 = int(d.xyxy[0][3].item())
                    #print(self.orig_img)
                    box_image = self.orig_img[y1:y2, x1:x2]
                    start = time.time()
                    label = ocr.recognize_text(images=[box_image])
                    spend = time.time()-start
                    #print(label)æ‰“å°æ–‡å­—è¯†åˆ«åˆæ¬¡ç»“æžœ
                    #print(spend,'text time')æ–‡å­—è¯†åˆ«æ—¶é—´
                    #delete_char1 = '!'
                    #delete_char2 = 'ï¼'
                    # åœ¨ä½ çš„ç¤ºä¾‹æ•°æ®ä¸­å¯»æ‰¾æ–‡æœ¬ä¸º 'é€šè¿‡' çš„å­—å…¸çš„ç´¢å¼•å·
                    """indices  = self.find_dict_index_by_text(label[0]['data'],'å¤±è´¥')
                    print("å­—å…¸åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•å·:", indices)"""
                    data = label[0]['data']
                    sorted_data = sorted(data,key=lambda x: (x['text_box_position'][0][1], x['text_box_position'][0][0]))
                    print(sorted_data)#æŽ’åºä¹‹åŽçš„æ–‡å­—è¯†åˆ«åˆ—è¡¨
                    #result = text.replace('!', '').replace('ï¼', '')
                    if len(sorted_data)>15:
                        if len(sorted_data[0]['text'])==2:
                            for i, entry in enumerate(sorted_data):
                                if entry['text'] == 'å¤±è´¥' or entry['text'] == 'å¤±è´­' and i + 1 < len(label[0]['data']):
                                    if i == 0:
                                        test_texts.append('æ¶¡è½®è‡ªæ£€å¤±è´¥')
                                    elif i == 2:
                                        test_texts.append('02æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 4:
                                        test_texts.append('å¸æ°”æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 6:
                                        test_texts.append('å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 8:
                                        test_texts.append('åŽ‹åŠ›ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 10:
                                        test_texts.append('å‘¼æ°”é˜€è‡ªæ£€å¤±è´¥')
                                    elif i == 12:
                                        test_texts.append('å®‰å…¨é˜€è‡ªæ£€å¤±è´¥')
                                    elif i == 14:
                                        test_texts.append('æ³„æ¼é‡è‡ªæ£€å¤±è´¥')
                                    elif i == 16:
                                        test_texts.append('é¡ºåº”æ€§è‡ªæ£€å¤±è´¥')
                                    elif i == 18:
                                        test_texts.append('æ³„æ¼é‡è‡ªæ£€å¤±è´¥')
                                    elif i == 20:
                                        test_texts.append('æ³„æ¼é‡è‡ªæ£€å¤±è´¥')
                        else:
                            for i, entry in enumerate(sorted_data):
                                if entry['text'] == 'å¤±è´¥' or entry['text'] == 'å¤±è´­'and i + 1 < len(label[0]['data']):
                                    if i == 1:
                                        test_texts.append('æ¶¡è½®è‡ªæ£€å¤±è´¥')
                                    elif i == 3:
                                        test_texts.append('02æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 5:
                                        test_texts.append('å¸æ°”æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 7:
                                        test_texts.append('å‘¼æ°”æµé‡ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 9:
                                        test_texts.append('åŽ‹åŠ›ä¼ æ„Ÿå™¨è‡ªæ£€å¤±è´¥')
                                    elif i == 11:
                                        test_texts.append('å‘¼æ°”é˜€è‡ªæ£€å¤±è´¥')
                                    elif i == 13:
                                        test_texts.append('å®‰å…¨é˜€è‡ªæ£€å¤±è´¥')
                                    elif i == 15:
                                        test_texts.append('æ³„æ¼é‡è‡ªæ£€å¤±è´¥')
                                    elif i == 17:
                                        test_texts.append('é¡ºåº”æ€§è‡ªæ£€å¤±è´¥')
                                    elif i == 19:
                                        test_texts.append('æ³„æ¼é‡è‡ªæ£€å¤±è´¥')
                                    elif i == 21:
                                        test_texts.append('æ³„æ¼é‡è‡ªæ£€å¤±è´¥')
                    else:
                        for item in sorted_data:
                            if 'å¤±è´¥' in item['text']:
                                test_texts.append(item['text'])
                    print(test_texts)#æ‰“å°è‡ªæ£€é”™è¯¯ä¿¡æ¯
                    name = ('' if id is None else f'id:{id} ') + names[c]
                    label = (f'{name} {conf:.2f}' if conf else name) if labels else None
                    annotator.box_label(d.xyxy.squeeze(), label, color=colors(c, True))

                if c ==4:#è¿è¡Œä¸­æŠ¥è­¦
                    #print(d.xyxy[0][0].item())
                    x1 = int(d.xyxy[0][0].item())
                    y1 = int(d.xyxy[0][1].item())
                    x2 = int(d.xyxy[0][2].item())
                    y2 = int(d.xyxy[0][3].item())
                    #print(self.orig_img)
                    box_image = self.orig_img[y1:y2, x1:x2]
                    start = time.time()
                    label = ocr.recognize_text(images=[box_image])
                    spend = time.time()-start
                    #print(spend,'text time')æ–‡å­—è¯†åˆ«èŠ±è´¹æ—¶é—´
                    #delete_char1 = '!'
                    #delete_char2 = 'ï¼'
                    item = label[0]['data']
                    for text in item:
                        text = text['text']
                        if len(text) > 1:
                            result1 = text.replace('!', '').replace('ï¼', '').replace('ï¼ˆ5ï¼‰','').replace('(1ï¼‰','')
                            warn_fault.append(result1)
                            label1 = (f'{result1} {conf:.2f}' if conf else result1) if labels else None
                            annotator.box_label(d.xyxy.squeeze(), label1, color=colors(c, True))
                    first_chinese_index = -1
                    # æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ±‰å­—çš„ç´¢å¼•
                    if len(warn_fault)==1:
                        for i, char in enumerate(warn_fault[0]):
                            if '\u4e00' <= char <= '\u9fff':
                                first_chinese_index = i
                                break
                        # æå–ç¬¬ä¸€ä¸ªæ±‰å­—åŠå…¶åŽé¢çš„æ‰€æœ‰ä¿¡æ¯
                        if first_chinese_index != -1:
                            chinese_and_after = warn_fault[0][first_chinese_index:]
                            warn_fault.append(chinese_and_after)
                        else:
                            print("æœªæ‰¾åˆ°æ±‰å­—")
                    print(warn_fault)#æ‰“å°é”™è¯¯ä¿¡æ¯

                else:
                    name = ('' if id is None else f'id:{id} ') + names[c]
                    label = (f'{name} {conf:.2f}' if conf else name) if labels else None
                    annotator.box_label(d.xyxy.squeeze(), label, color=colors(c, True))
            if type_number == 'comen':#æ ¹æ®åž‹å·é€‰æ‹©é”™è¯¯åº”å¯¹åŠžæ³•
                final_fault = comen_faut
            elif type_number == 'aeonmed':
                final_fault = aeonmed_fault
            elif type_number == 'mindray':
                final_fault = comen_faut
            #print(final_fault)æ‰“å°è°ƒç”¨åž‹å·é”™è¯¯æ•°æ®åº“
            if set_label:#æ ‡å¿—ä½åˆ¤æ–­ æ˜¯å¦è‡ªæ£€æŠ¥é”™å’Œè¿è¡Œä¸­æŠ¥é”™
                for test in test_texts:#è‡ªæ£€é”™è¯¯
                    if test in final_fault:
                        final_text[test] = final_fault[test]
                        # Handle the case where warn_fault is not in final_fault
                    else:
                        final_text = {f'å¤±è´¥{i + 1}': text for i, text in enumerate(test_texts)}
            else:
                for test in warn_fault:#æŠ¥è­¦é”™è¯¯
                    if test in final_fault:
                        final_text[test] = final_fault[test]
                    if test == 'å®¤æ¯':
                        final_text['çª’æ¯'] = final_fault['çª’æ¯']
            print(final_text)#æœ€ç»ˆæŠ¥é”™ä¿¡æ¯
            #print(text_num)æ£€æµ‹åˆ°å„ç§ç›®æ ‡æ¡†çš„åºå·ï¼ˆåºå·åŒdata.yamlä¸€æ ·ï¼‰

        # Plot Classify results
        if pred_probs is not None and show_probs:
            text = ',\n'.join(f'{names[j] if names else j} {pred_probs.data[j]:.2f}' for j in pred_probs.top5)
            x = round(self.orig_shape[0] * 0.03)
            annotator.text([x, x], text, txt_color=(255, 255, 255))  # TODO: allow setting colors

        # Plot Pose results
        if self.keypoints is not None:
            for k in reversed(self.keypoints.data):
                annotator.kpts(k, self.orig_shape, radius=kpt_radius, kpt_line=kpt_line)

        return annotator.result(),final_text#å›¾åƒ

    def find_dict_index_by_text(self, result_data, text):
        indices = []
        for i, dictionary in enumerate(result_data):
            if 'text' in dictionary and dictionary['text'] == text:
                indices.append(i)
        return indices

    def verbose(self):
        """Return log string for each task."""
        log_string = ''
        probs = self.probs
        boxes = self.boxes
        if len(self) == 0:
            return log_string if probs is not None else f'{log_string}(no detections), '
        if probs is not None:
            log_string += f"{', '.join(f'{self.names[j]} {probs.data[j]:.2f}' for j in probs.top5)}, "
        if boxes:
            for c in boxes.cls.unique():
                n = (boxes.cls == c).sum()  # detections per class
                log_string += f"{n} {self.names[int(c)]}{'s' * (n > 1)}, "
        return log_string

    def save_txt(self, txt_file, save_conf=False):
        """
        Save predictions into txt file.

        Args:
            txt_file (str): txt file path.
            save_conf (bool): save confidence score or not.
        """
        boxes = self.boxes
        masks = self.masks
        probs = self.probs
        kpts = self.keypoints
        texts = []
        if probs is not None:
            # Classify
            [texts.append(f'{probs.data[j]:.2f} {self.names[j]}') for j in probs.top5]
        elif boxes:
            # Detect/segment/pose
            for j, d in enumerate(boxes):
                c, conf, id = int(d.cls), float(d.conf), None if d.id is None else int(d.id.item())
                line = (c, *d.xywhn.view(-1))
                if masks:
                    seg = masks[j].xyn[0].copy().reshape(-1)  # reversed mask.xyn, (n,2) to (n*2)
                    line = (c, *seg)
                if kpts is not None:
                    kpt = torch.cat((kpts[j].xyn, kpts[j].conf[..., None]), 2) if kpts[j].has_visible else kpts[j].xyn
                    line += (*kpt.reshape(-1).tolist(), )
                line += (conf, ) * save_conf + (() if id is None else (id, ))
                texts.append(('%g ' * len(line)).rstrip() % line)

        if texts:
            Path(txt_file).parent.mkdir(parents=True, exist_ok=True)  # make directory
            with open(txt_file, 'a') as f:
                f.writelines(text + '\n' for text in texts)

    def save_crop(self, save_dir, file_name=Path('im.jpg')):
        """
        Save cropped predictions to `save_dir/cls/file_name.jpg`.

        Args:
            save_dir (str | pathlib.Path): Save path.
            file_name (str | pathlib.Path): File name.
        """
        if self.probs is not None:
            LOGGER.warning('WARNING âš ï¸ Classify task do not support `save_crop`.')
            return
        for d in self.boxes:
            save_one_box(d.xyxy,
                         self.orig_img.copy(),
                         file=Path(save_dir) / self.names[int(d.cls)] / f'{Path(file_name).stem}.jpg',
                         BGR=True)

    def tojson(self, normalize=False):
        """Convert the object to JSON format."""
        if self.probs is not None:
            LOGGER.warning('Warning: Classify task do not support `tojson` yet.')
            return

        import json

        # Create list of detection dictionaries
        results = []
        data = self.boxes.data.cpu().tolist()
        h, w = self.orig_shape if normalize else (1, 1)
        for i, row in enumerate(data):  # xyxy, track_id if tracking, conf, class_id
            box = {'x1': row[0] / w, 'y1': row[1] / h, 'x2': row[2] / w, 'y2': row[3] / h}
            conf = row[-2]
            class_id = int(row[-1])
            name = self.names[class_id]
            result = {'name': name, 'class': class_id, 'confidence': conf, 'box': box}
            if self.boxes.is_track:
                result['track_id'] = int(row[-3])  # track ID
            if self.masks:
                x, y = self.masks.xy[i][:, 0], self.masks.xy[i][:, 1]  # numpy array
                result['segments'] = {'x': (x / w).tolist(), 'y': (y / h).tolist()}
            if self.keypoints is not None:
                x, y, visible = self.keypoints[i].data[0].cpu().unbind(dim=1)  # torch Tensor
                result['keypoints'] = {'x': (x / w).tolist(), 'y': (y / h).tolist(), 'visible': visible.tolist()}
            results.append(result)

        # Convert detections to JSON
        return json.dumps(results, indent=2)


class Boxes(BaseTensor):
    """
    A class for storing and manipulating detection boxes.

    Args:
        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,
            with shape (num_boxes, 6) or (num_boxes, 7). The last two columns contain confidence and class values.
            If present, the third last column contains track IDs.
        orig_shape (tuple): Original image size, in the format (height, width).

    Attributes:
        xyxy (torch.Tensor | numpy.ndarray): The boxes in xyxy format.
        conf (torch.Tensor | numpy.ndarray): The confidence values of the boxes.
        cls (torch.Tensor | numpy.ndarray): The class values of the boxes.
        id (torch.Tensor | numpy.ndarray): The track IDs of the boxes (if available).
        xywh (torch.Tensor | numpy.ndarray): The boxes in xywh format.
        xyxyn (torch.Tensor | numpy.ndarray): The boxes in xyxy format normalized by original image size.
        xywhn (torch.Tensor | numpy.ndarray): The boxes in xywh format normalized by original image size.
        data (torch.Tensor): The raw bboxes tensor (alias for `boxes`).

    Methods:
        cpu(): Move the object to CPU memory.
        numpy(): Convert the object to a numpy array.
        cuda(): Move the object to CUDA memory.
        to(*args, **kwargs): Move the object to the specified device.
    """

    def __init__(self, boxes, orig_shape) -> None:
        """Initialize the Boxes class."""
        if boxes.ndim == 1:
            boxes = boxes[None, :]
        n = boxes.shape[-1]
        assert n in (6, 7), f'expected `n` in [6, 7], but got {n}'  # xyxy, track_id, conf, cls
        super().__init__(boxes, orig_shape)
        self.is_track = n == 7
        self.orig_shape = orig_shape

    @property
    def xyxy(self):
        """Return the boxes in xyxy format."""
        return self.data[:, :4]

    @property
    def conf(self):
        """Return the confidence values of the boxes."""
        return self.data[:, -2]

    @property
    def cls(self):
        """Return the class values of the boxes."""
        return self.data[:, -1]

    @property
    def id(self):
        """Return the track IDs of the boxes (if available)."""
        return self.data[:, -3] if self.is_track else None

    @property
    @lru_cache(maxsize=2)  # maxsize 1 should suffice
    def xywh(self):
        """Return the boxes in xywh format."""
        return ops.xyxy2xywh(self.xyxy)

    @property
    @lru_cache(maxsize=2)
    def xyxyn(self):
        """Return the boxes in xyxy format normalized by original image size."""
        xyxy = self.xyxy.clone() if isinstance(self.xyxy, torch.Tensor) else np.copy(self.xyxy)
        xyxy[..., [0, 2]] /= self.orig_shape[1]
        xyxy[..., [1, 3]] /= self.orig_shape[0]
        return xyxy

    @property
    @lru_cache(maxsize=2)
    def xywhn(self):
        """Return the boxes in xywh format normalized by original image size."""
        xywh = ops.xyxy2xywh(self.xyxy)
        xywh[..., [0, 2]] /= self.orig_shape[1]
        xywh[..., [1, 3]] /= self.orig_shape[0]
        return xywh


class Masks(BaseTensor):
    """
    A class for storing and manipulating detection masks.

    Attributes:
        xy (list): A list of segments in pixel coordinates.
        xyn (list): A list of normalized segments.

    Methods:
        cpu(): Returns the masks tensor on CPU memory.
        numpy(): Returns the masks tensor as a numpy array.
        cuda(): Returns the masks tensor on GPU memory.
        to(device, dtype): Returns the masks tensor with the specified device and dtype.
    """

    def __init__(self, masks, orig_shape) -> None:
        """Initialize the Masks class with the given masks tensor and original image shape."""
        if masks.ndim == 2:
            masks = masks[None, :]
        super().__init__(masks, orig_shape)

    @property
    @lru_cache(maxsize=1)
    def xyn(self):
        """Return normalized segments."""
        return [
            ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=True)
            for x in ops.masks2segments(self.data)]

    @property
    @lru_cache(maxsize=1)
    def xy(self):
        """Return segments in pixel coordinates."""
        return [
            ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=False)
            for x in ops.masks2segments(self.data)]


class Keypoints(BaseTensor):
    """
    A class for storing and manipulating detection keypoints.

    Attributes:
        xy (torch.Tensor): A collection of keypoints containing x, y coordinates for each detection.
        xyn (torch.Tensor): A normalized version of xy with coordinates in the range [0, 1].
        conf (torch.Tensor): Confidence values associated with keypoints if available, otherwise None.

    Methods:
        cpu(): Returns a copy of the keypoints tensor on CPU memory.
        numpy(): Returns a copy of the keypoints tensor as a numpy array.
        cuda(): Returns a copy of the keypoints tensor on GPU memory.
        to(device, dtype): Returns a copy of the keypoints tensor with the specified device and dtype.
    """

    @smart_inference_mode()  # avoid keypoints < conf in-place error
    def __init__(self, keypoints, orig_shape) -> None:
        """Initializes the Keypoints object with detection keypoints and original image size."""
        if keypoints.ndim == 2:
            keypoints = keypoints[None, :]
        if keypoints.shape[2] == 3:  # x, y, conf
            mask = keypoints[..., 2] < 0.5  # points with conf < 0.5 (not visible)
            keypoints[..., :2][mask] = 0
        super().__init__(keypoints, orig_shape)
        self.has_visible = self.data.shape[-1] == 3

    @property
    @lru_cache(maxsize=1)
    def xy(self):
        """Returns x, y coordinates of keypoints."""
        return self.data[..., :2]

    @property
    @lru_cache(maxsize=1)
    def xyn(self):
        """Returns normalized x, y coordinates of keypoints."""
        xy = self.xy.clone() if isinstance(self.xy, torch.Tensor) else np.copy(self.xy)
        xy[..., 0] /= self.orig_shape[1]
        xy[..., 1] /= self.orig_shape[0]
        return xy

    @property
    @lru_cache(maxsize=1)
    def conf(self):
        """Returns confidence values of keypoints if available, else None."""
        return self.data[..., 2] if self.has_visible else None


class Probs(BaseTensor):
    """
    A class for storing and manipulating classification predictions.

    Attributes:
        top1 (int): Index of the top 1 class.
        top5 (list[int]): Indices of the top 5 classes.
        top1conf (torch.Tensor): Confidence of the top 1 class.
        top5conf (torch.Tensor): Confidences of the top 5 classes.

    Methods:
        cpu(): Returns a copy of the probs tensor on CPU memory.
        numpy(): Returns a copy of the probs tensor as a numpy array.
        cuda(): Returns a copy of the probs tensor on GPU memory.
        to(): Returns a copy of the probs tensor with the specified device and dtype.
    """

    def __init__(self, probs, orig_shape=None) -> None:
        """Initialize the Probs class with classification probabilities and optional original shape of the image."""
        super().__init__(probs, orig_shape)

    @property
    @lru_cache(maxsize=1)
    def top1(self):
        """Return the index of top 1."""
        return int(self.data.argmax())

    @property
    @lru_cache(maxsize=1)
    def top5(self):
        """Return the indices of top 5."""
        return (-self.data).argsort(0)[:5].tolist()  # this way works with both torch and numpy.

    @property
    @lru_cache(maxsize=1)
    def top1conf(self):
        """Return the confidence of top 1."""
        return self.data[self.top1]

    @property
    @lru_cache(maxsize=1)
    def top5conf(self):
        """Return the confidences of top 5."""
        return self.data[self.top5]
