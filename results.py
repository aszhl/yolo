# Ultralytics YOLO üöÄ, AGPL-3.0 license
"""
Ultralytics Results, Boxes and Masks classes for handling inference results.

Usage: See https://docs.ultralytics.com/modes/predict/
"""

from copy import deepcopy
from functools import lru_cache
from pathlib import Path

import numpy as np
import torch
import time

from ultralytics.data.augment import LetterBox
from ultralytics.utils import LOGGER, SimpleClass, ops
from ultralytics.utils.plotting import Annotator, colors, save_one_box
from ultralytics.utils.torch_utils import smart_inference_mode
#from word import word_detect

import paddlehub as hub
ocr = hub.Module(name="ch_pp-ocrv3", enable_mkldnn=True)# mkldnnÂä†ÈÄü‰ªÖÂú®CPU‰∏ãÊúâÊïà

class BaseTensor(SimpleClass):
    """Base tensor class with additional methods for easy manipulation and device handling."""

    def __init__(self, data, orig_shape) -> None:
        """
        Initialize BaseTensor with data and original shape.

        Args:
            data (torch.Tensor | np.ndarray): Predictions, such as bboxes, masks and keypoints.
            orig_shape (tuple): Original shape of image.
        """
        assert isinstance(data, (torch.Tensor, np.ndarray))
        self.data = data
        self.orig_shape = orig_shape

    @property
    def shape(self):
        """Return the shape of the data tensor."""
        return self.data.shape

    def cpu(self):
        """Return a copy of the tensor on CPU memory."""
        return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.cpu(), self.orig_shape)

    def numpy(self):
        """Return a copy of the tensor as a numpy array."""
        return self if isinstance(self.data, np.ndarray) else self.__class__(self.data.numpy(), self.orig_shape)

    def cuda(self):
        """Return a copy of the tensor on GPU memory."""
        return self.__class__(torch.as_tensor(self.data).cuda(), self.orig_shape)

    def to(self, *args, **kwargs):
        """Return a copy of the tensor with the specified device and dtype."""
        return self.__class__(torch.as_tensor(self.data).to(*args, **kwargs), self.orig_shape)

    def __len__(self):  # override len(results)
        """Return the length of the data tensor."""
        return len(self.data)

    def __getitem__(self, idx):
        """Return a BaseTensor with the specified index of the data tensor."""
        return self.__class__(self.data[idx], self.orig_shape)


class Results(SimpleClass):
    """
    A class for storing and manipulating inference results.

    Args:
        orig_img (numpy.ndarray): The original image as a numpy array.
        path (str): The path to the image file.
        names (dict): A dictionary of class names.
        boxes (torch.tensor, optional): A 2D tensor of bounding box coordinates for each detection.
        masks (torch.tensor, optional): A 3D tensor of detection masks, where each mask is a binary image.
        probs (torch.tensor, optional): A 1D tensor of probabilities of each class for classification task.
        keypoints (List[List[float]], optional): A list of detected keypoints for each object.

    Attributes:
        orig_img (numpy.ndarray): The original image as a numpy array.
        orig_shape (tuple): The original image shape in (height, width) format.
        boxes (Boxes, optional): A Boxes object containing the detection bounding boxes.
        masks (Masks, optional): A Masks object containing the detection masks.
        probs (Probs, optional): A Probs object containing probabilities of each class for classification task.
        keypoints (Keypoints, optional): A Keypoints object containing detected keypoints for each object.
        speed (dict): A dictionary of preprocess, inference, and postprocess speeds in milliseconds per image.
        names (dict): A dictionary of class names.
        path (str): The path to the image file.
        _keys (tuple): A tuple of attribute names for non-empty attributes.
    """

    def __init__(self, orig_img, path, names, boxes=None, masks=None, probs=None, keypoints=None) -> None:
        """Initialize the Results class."""
        self.orig_img = orig_img
        self.orig_shape = orig_img.shape[:2]
        self.boxes = Boxes(boxes, self.orig_shape) if boxes is not None else None  # native size boxes
        self.masks = Masks(masks, self.orig_shape) if masks is not None else None  # native size or imgsz masks
        self.probs = Probs(probs) if probs is not None else None
        self.keypoints = Keypoints(keypoints, self.orig_shape) if keypoints is not None else None
        self.speed = {'preprocess': None, 'inference': None, 'postprocess': None}  # milliseconds per image
        self.names = names
        self.path = path
        self.save_dir = None
        self._keys = 'boxes', 'masks', 'probs', 'keypoints'

    def __getitem__(self, idx):
        """Return a Results object for the specified index."""
        return self._apply('__getitem__', idx)

    def __len__(self):
        """Return the number of detections in the Results object."""
        for k in self._keys:
            v = getattr(self, k)
            if v is not None:
                return len(v)

    def update(self, boxes=None, masks=None, probs=None):
        """Update the boxes, masks, and probs attributes of the Results object."""
        if boxes is not None:
            ops.clip_boxes(boxes, self.orig_shape)  # clip boxes
            self.boxes = Boxes(boxes, self.orig_shape)
        if masks is not None:
            self.masks = Masks(masks, self.orig_shape)
        if probs is not None:
            self.probs = probs

    def _apply(self, fn, *args, **kwargs):
        """
        Applies a function to all non-empty attributes and returns a new Results object with modified attributes. This
        function is internally called by methods like .to(), .cuda(), .cpu(), etc.

        Args:
            fn (str): The name of the function to apply.
            *args: Variable length argument list to pass to the function.
            **kwargs: Arbitrary keyword arguments to pass to the function.

        Returns:
            Results: A new Results object with attributes modified by the applied function.
        """
        r = self.new()
        for k in self._keys:
            v = getattr(self, k)
            if v is not None:
                setattr(r, k, getattr(v, fn)(*args, **kwargs))
        return r

    def cpu(self):
        """Return a copy of the Results object with all tensors on CPU memory."""
        return self._apply('cpu')

    def numpy(self):
        """Return a copy of the Results object with all tensors as numpy arrays."""
        return self._apply('numpy')

    def cuda(self):
        """Return a copy of the Results object with all tensors on GPU memory."""
        return self._apply('cuda')

    def to(self, *args, **kwargs):
        """Return a copy of the Results object with tensors on the specified device and dtype."""
        return self._apply('to', *args, **kwargs)

    def new(self):
        """Return a new Results object with the same image, path, and names."""
        return Results(orig_img=self.orig_img, path=self.path, names=self.names)

    def plot(
        self,
        conf=True,
        line_width=None,
        font_size=None,
        font=r'E:\Anaconda\envs\y8\Lib\site-packages\matplotlib\mpl-data\fonts\ttf\simhei.ttf',
        pil=True,
        img=None,
        im_gpu=None,
        kpt_radius=5,
        kpt_line=True,
        labels=True,
        boxes=True,
        masks=True,
        probs=True,
    ):
        """
        Plots the detection results on an input RGB image. Accepts a numpy array (cv2) or a PIL Image.

        Args:
            conf (bool): Whether to plot the detection confidence score.
            line_width (float, optional): The line width of the bounding boxes. If None, it is scaled to the image size.
            font_size (float, optional): The font size of the text. If None, it is scaled to the image size.
            font (str): The font to use for the text.
            pil (bool): Whether to return the image as a PIL Image.
            img (numpy.ndarray): Plot to another image. if not, plot to original image.
            im_gpu (torch.Tensor): Normalized image in gpu with shape (1, 3, 640, 640), for faster mask plotting.
            kpt_radius (int, optional): Radius of the drawn keypoints. Default is 5.
            kpt_line (bool): Whether to draw lines connecting keypoints.
            labels (bool): Whether to plot the label of bounding boxes.
            boxes (bool): Whether to plot the bounding boxes.
            masks (bool): Whether to plot the masks.
            probs (bool): Whether to plot classification probability

        Returns:
            (numpy.ndarray): A numpy array of the annotated image.

        Example:
            ```python
            from PIL import Image
            from ultralytics import YOLO

            model = YOLO('yolov8n.pt')
            results = model('bus.jpg')  # results list
            for r in results:
                im_array = r.plot()  # plot a BGR numpy array of predictions
                im = Image.fromarray(im_array[..., ::-1])  # RGB PIL image
                im.show()  # show image
                im.save('results.jpg')  # save image
            ```
        """
        #print(img)
        if img is None and isinstance(self.orig_img, torch.Tensor):
            img = (self.orig_img[0].detach().permute(1, 2, 0).contiguous() * 255).to(torch.uint8).cpu().numpy()


        names = self.names
        fault='Êó†ÊïÖÈöú'
        final_text = {}  # ÊúÄÁªàË∞ÉÁî®Êï∞ÊçÆ
        pred_boxes, show_boxes = self.boxes, boxes
        pred_masks, show_masks = self.masks, masks
        pred_probs, show_probs = self.probs, probs
        annotator = Annotator(
            deepcopy(self.orig_img if img is None else img),
            line_width,
            font_size,
            font,
            pil or (pred_probs is not None and show_probs),  # Classify tasks default to pil=True
            example=names)

        # Plot Segment results
        if pred_masks and show_masks:
            if im_gpu is None:
                img = LetterBox(pred_masks.shape[1:])(image=annotator.result())
                im_gpu = torch.as_tensor(img, dtype=torch.float16, device=pred_masks.data.device).permute(
                    2, 0, 1).flip(0).contiguous() / 255
            idx = pred_boxes.cls if pred_boxes else range(len(pred_masks))
            annotator.masks(pred_masks.data, colors=[colors(x, True) for x in idx], im_gpu=im_gpu)

        # Plot Detect results
        if pred_boxes and show_boxes:
            #print(names)
            text_num=[]
            text_fault=''
            warn_fault=[]
            type_number = ''
            set_label = False
            comen_faut={   'ÂëºÂê∏Êú∫Êó†Ê≥ïÂêØÂä®':{'ÂéüÂõ†':'1.Ê≤°ÊúâËøûÊé• AC ÁîµÊ∫êÔºå‰∏îÁîµÊ±†ÁîµÈáè‰∏çË∂≥;2.AC ËæìÂÖ•ÊèíÂ∫ß‰øùÈô©‰∏ùÁÜîÊñ≠Ôºå‰∏îÁîµÊ±†ÁîµÈáè‰∏çË∂≥;3.ÊòæÁ§∫ÁîµÁºÜÔºàÊØçÊùøÂ§ÑÊàñ‰∏ªÊú∫Â§ñÈÉ®ËøûÊé•Âô®Â§ÑÔºâËÑ±ËêΩÊàñËøûÊé•‰∏çÂèØÈù†;4. AC-DC ÊùøÁ°¨‰ª∂ÁîµË∑ØÊïÖÈöúÂØºËá¥Ê≤°Êúâ18.8V ÁîµÊ∫êËæìÂá∫Ôºå‰∏îÁîµÊ±†ÁîµÈáè‰∏çË∂≥;5.DC-DC ÊùøÁ°¨‰ª∂ÁîµË∑ØÊïÖÈöúÂØºËá¥Ê≤°Êúâ5V„ÄÅ3.3V„ÄÅ7V„ÄÅ12V Á≠âÁõ¥ÊµÅÁîµÊ∫êËæìÂá∫','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü•Âπ∂Á°Æ‰øù AC ÁîµÊ∫êÊ≠£Á°ÆËøûÊé•;2.Êõ¥Êç¢‰øùÈô©‰∏ùÔºåÊõ¥Êç¢‰øùÈô©‰∏ùÂêéÂ¶ÇÊûúÂºÄÊú∫Êó∂ÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåÂàôËØ¥ÊòéÊú∫Âô®ÂÜÖÈÉ®Â≠òÂú®Áü≠Ë∑ØÁé∞Ë±°;3.Ê£ÄÊü•Âπ∂Á°Æ‰øùÁ∫øÁºÜÂèØÈù†ËøûÊé•ÔºåÂπ∂Á°Æ‰øùÊòæÁ§∫ÁîµÁºÜÁöÑÁ¥ßÂõ∫Ëû∫Èíâ‰∏∫ÊãßÁ¥ßÁä∂ÊÄÅ;4.Ê£ÄÊü•Âπ∂Á°Æ‰øùÁ∫øÁºÜÂèØÈù†ËøûÊé•;5.Êõ¥Êç¢ AC-DC Êùø;6.Êõ¥Êç¢ DC-DC Êùø'},
                           'Â±èÂπïÊ≤°ÊúâÊòæÁ§∫(ÈªëÂ±è)':{'ÂéüÂõ†':'1.ÈÄÜÂèòÂô®ËøûÊé•Á∫øÔºàÂåÖÊã¨ÈÄÜÂèòÂô®ËæìÂÖ•Á∫øÂíåËæìÂá∫Á∫øÔºâËÑ±ËêΩÊàñËøûÊé•‰∏çÂèØÈù†;2.ÈÄÜÂèòÂô®ÊçüÂùè;3.‰∏ªÊéßÊùøÁ°¨‰ª∂ÊïÖÈöúÔºåÂØºËá¥ËÉåÂÖâ‰ΩøËÉΩ‰ø°Âè∑ËæìÂá∫Êó†ÊïàÁîµÂπ≥;4.‰∏ªÊéßÊùøËΩØ‰ª∂ÊïÖÈöúÔºåÂØºËá¥ËÉåÂÖâ‰ΩøËÉΩ‰ø°Âè∑ËæìÂá∫Êó†ÊïàÁîµÂπ≥;5.LCD ÊçüÂùè','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü•Âπ∂Á°Æ‰øùÁ∫øÁºÜÂèØÈù†ËøûÊé•;2.Êõ¥Êç¢ÈÄÜÂèòÂô®;3.Êõ¥Êç¢‰∏ªÊéßÊùø;4.ÂçáÁ∫ß‰∏ªÊéßÊùøËΩØ‰ª∂;5.Êõ¥Êç¢ LCD'},
                           'ÁôΩÂ±è':{'ÂéüÂõ†':'1.ÊòæÁ§∫ÁîµÁºÜÔºàLCD Â§ÑÔºâËÑ±ËêΩÊàñËøûÊé•‰∏çÂèØÈù†;2.‰∏ªÊéßÊùøÁ°¨‰ª∂ÊïÖÈöúÔºåÂØºËá¥ LCD ‰æõÁîµÁîµÊ∫ê 3.3V Êó†ËæìÂá∫ÊàñËæìÂá∫ÂºÇÂ∏∏;3.LCDÊçüÂùè','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü•Âπ∂Á°Æ‰øùÁ∫øÁºÜÂèØÈù†ËøûÊé•;2.Êõ¥Êç¢‰∏ªÊéßÊùø;3.Êõ¥Êç¢ LCD'},
                           'Ëä±Â±è':{'ÂéüÂõ†':'ÊòæÁ§∫ÁîµÁºÜÔºàLCD Â§ÑÔºâËÑ±ËêΩÊàñËøûÊé•‰∏çÂèØÈù†ÔºåÂØºËá¥ÈÉ®ÂàÜÈ¢úËâ≤‰ø°Âè∑‰∏¢Â§±','Ëß£ÂÜ≥ÂäûÊ≥ï':'Ê£ÄÊü•Âπ∂Á°Æ‰øùÁ∫øÁºÜÂèØÈù†ËøûÊé•'},
                           'È£éÊâáÊïÖÈöú':{'ÂéüÂõ†':'1.È£éÊâáÂ†µÂ°û;2.È£éÊâáËøûÊé•Á∫øËÑ±ËêΩÊàñÈ£éÊâáÊïÖÈöú;3.DC-DC ÊùøÁªôÈ£éÊâá‰æõÁîµÁöÑ 12V ÊçüÂùè','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Êü•ÁúãÈ£éÊâáÂ†µÂ°ûÊÉÖÂÜµÔºåÂπ∂Ê∏ÖÈô§ÈöúÁ¢çÁâ©;2.ÈáçÁé∞ÊèíÊãîÈ£éÊâáËøûÊé•Á∫øÊàñÊõ¥Êç¢È£éÊâá;3.Êõ¥Êç¢ DC-DC Êùø'},
                           'Ê∂°ËΩÆËá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.Ê∂°ËΩÆ‰æõÁîµËøûÊé•Á∫øÊñ≠ÂºÄ;2.Ê∂°ËΩÆÊïÖÈöú','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Á°ÆËÆ§Ê∂°ËΩÆ‰æõÁîµÁîµÁ∫øËøûÊé•Ê≠£Á°Æ;2.Êõ¥Êç¢Ê∂°ËΩÆ'},
                           '02ÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.È´òÂéãÊ∞ß‰æõÊ∞î‰∏çË∂≥„ÄÇ2.‰ΩéÂéãÊ∞ßÈÄöÊ∞î„ÄÇ3.Ê∞ßÊ∞îÊØî‰æãÈòÄ‰∏é02ÊµÅÈáè‰º†ÊÑüÂô®ÂÅèÂ∑ÆËæÉÂ§ß„ÄÇ4.Ê∞ßÊ∞îÊØî‰æãÈòÄÊïÖÈöú„ÄÇ5.02ÊµÅÈáè‰º†ÊÑüÂô®ÊïÖÈöú','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü•ÊòØÂê¶ËøûÊé•È´òÂéãÊ∞ßÊ∞îÊ∫êÔºå‰∏îÊ∞îÊ∫êÊòØÂê¶ÂÖÖË∂≥„ÄÇ2.Âú®„Äê‰∏ªËèúÂçï„Äë‚Üí„ÄêÁª¥Êä§„Äë‚Üí„ÄêÁî®Êà∑Áª¥Êä§„Äë‚ÜíËæìÂÖ•Áî®Êà∑Áª¥Êä§ÂØÜÁ†Å‚Üí„ÄêËÆæÁΩÆ„Äë‚Üí„ÄêÊ∞îÊ∫ê„Äë‚Üí„ÄêÊ∞ßÊ∞îÊ∞îÊ∫êÁ±ªÂûã„ÄëÊü•ÁúãÈÄâÊã©ÁöÑÊòØÂê¶ÊòØ‰ΩéÂéãÊ∞ßÔºåÂ¶ÇÊûúÊòØÔºåËØ∑ÂàáÊç¢‰∏∫È´òÂéãÊ∞ß„ÄÇ3.ÈáçÊñ∞ÊâßË°åÊµÅÈáèÊ†°ÂáÜ„ÄÇ4.Âú®ÈòÄÈó®ËØäÊñ≠ÁïåÈù¢ËØäÊñ≠Ê∞ßÊ∞îÊØî‰æãÈòÄÊòØÂê¶ÂºÇÂ∏∏ÔºàÂèÇËßÅ Âê∏Ê∞îÈòÄÊàñÊ∞ßÊ∞îÊØî‰æãÈòÄÁä∂ÊÄÅÂºÇÂ∏∏ËØäÊñ≠ÔºâÔºåÂ¶ÇÊûúÂºÇÂ∏∏Êõ¥Êç¢Ê∞ßÊ∞îÊØî‰æãÈòÄÔºåÈáçÊñ∞ÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ5.Ê£ÄÊü•O2ÊµÅÈáè‰º†ÊÑüÂô®ÊòØÂê¶Ê≠£Á°ÆËøûÊé•ÔºåÂ¶ÇÊûúÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåËØ∑Êõ¥Êç¢ O2 ÊµÅÈáè‰º†ÊÑüÂô®ÔºåÈáçÊñ∞ÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ6.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®‰∏éÂê∏Ê∞îÈòÄÁöÑÂºÄÈòÄÊµÅÈÄüÂÅèÂ∑ÆËæÉÂ§ß„ÄÇ2.Âê∏Ê∞îÈòÄÊïÖÈöú„ÄÇ3.Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊïÖÈöú','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.ÈáçÊñ∞ÊâßË°åÊµÅÈáèÊ†°ÂáÜÔºåÂèÇËßÅÊµÅÈáèÊ†°ÂáÜ„ÄÇ2.Âú®ÈòÄÈó®ËØäÊñ≠ÁïåÈù¢ËØäÊñ≠Âê∏Ê∞îÈòÄÊòØÂê¶ÂºÇÂ∏∏ÔºàÂê∏Ê∞îÈòÄÊàñÊ∞ßÊ∞îÊØî‰æãÈòÄÁä∂ÊÄÅÂºÇÂ∏∏ËØäÊñ≠ÔºâÔºåÂ¶ÇÊûúÂºÇÂ∏∏Êõ¥Êç¢Âê∏Ê∞îÈòÄÔºåÈáçÊñ∞ÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ3.Ê£ÄÊü•Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊòØÂê¶Ê≠£Á°ÆËøûÊé•ÔºåÂ¶ÇÊûúÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåÊõ¥Êç¢Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÔºåÈáçÊñ∞ÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ4.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.YpieceÊ≤°Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊú™ËøûÊé•;2.ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®‰∏éÂê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãÈáèÊµÅÈÄüÂÅèÂ∑ÆËæÉÂ§ß;3.ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÊïÖÈöú','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü• Ypiece ÊòØÂê¶Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊòØÂê¶ËøûÊé•„ÄÇ2.ÈáçÊñ∞ÊâßË°åÊµÅÈáèÊ†°ÂáÜ„ÄÇ3.Ê£ÄÊü•ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÊòØÂê¶Ê≠£Á°ÆËøûÊé•ÔºåÂ¶ÇÊûúÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåÊõ¥Êç¢ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÔºåÈáçÊñ∞ÊâßË°åÊµÅÈáèÊ†°ÂáÜÂíåÁ≥ªÁªüËá™Ê£Ä„ÄÇ4.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'ÂéãÂäõ‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.Ypiece Ê≤°Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊú™ËøûÊé•„ÄÇ2.Âê∏Ê∞îÂéãÂäõ‰º†ÊÑüÂô®„ÄÅÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂéãÂäõÂíåÂëºÊ∞îÈòÄÂºÄÈòÄÂéãÂäõÂÅèÂ∑ÆËæÉÂ§ß„ÄÇ3.Âê∏Ê∞îÂéãÂäõ„ÄÅÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÈááÊ†∑ÁÆ°Êú™ËøûÊé•ÊàñÊºèÊ∞î„ÄÇ4.ÂëºÊ∞îÈòÄÊú™ÂÆâË£ÖÊàñÂëºÊ∞îÈòÄ‰æõÁîµÂºÇÂ∏∏„ÄÇ5.ÂëºÊ∞îÈòÄÂºÇÂ∏∏','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü• Ypiece ÊòØÂê¶Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊòØÂê¶ËøûÊé•„ÄÇ2.ÈáçÊñ∞ÊâßË°åÂéãÂäõÊ†°ÂáÜ„ÄÇ3.Á°ÆËÆ§Âê∏Ê∞îÂéãÂäõ„ÄÅÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÈááÊ†∑ÁÆ°ÊòØÂê¶ÂÆåÂ•ΩÔºàÊó†Êñ≠Ë£ÇÔºâ‰∏îÊ≠£Á°ÆËøûÊé•„ÄÇ4.Á°ÆËÆ§ÂëºÊ∞îÈòÄ‰æõÁîµÁîµÁ∫øËøûÊé•Ê≠£Á°ÆÔºåÂëºÊ∞îÈòÄÂÆâË£ÖÊ≠£Á°ÆÔºåÈáçÊñ∞ÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ5.Âú®ÈòÄÈó®ËØäÊñ≠ÁïåÈù¢ËØäÊñ≠ÂëºÊ∞îÈòÄÊòØÂê¶ÂºÇÂ∏∏ÔºàÂèÇËßÅÂëºÊ∞îÈòÄÁä∂ÊÄÅÂºÇÂ∏∏ËØäÊñ≠ÔºâÔºåÂ¶ÇÊûúÂºÇÂ∏∏ÔºåÂàôÊõ¥Êç¢ÂëºÊ∞îÈòÄÔºåÂÜçÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ6.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'ÂëºÊ∞îÈòÄËá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.YpieceÊ≤°Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊú™ËøûÊé•„ÄÇ2.Âê∏Ê∞îÂéãÂäõ‰º†ÊÑüÂô®„ÄÅÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂéãÂäõÂíåÂëºÊ∞îÈòÄÂºÄÈòÄÂéãÂäõÂÅèÂ∑ÆËæÉÂ§ß„ÄÇ3.Âê∏Ê∞îÂéãÂäõ„ÄÅÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÈááÊ†∑ÁÆ°Êú™ËøûÊé•ÊàñÊºèÊ∞î„ÄÇ4.ÂëºÊ∞îÈòÄÊú™ÂÆâË£ÖÊàñÂëºÊ∞îÈòÄ‰æõÁîµÂºÇÂ∏∏„ÄÇ5.ÂëºÊ∞îÈòÄÂºÇÂ∏∏','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü• Ypiece ÊòØÂê¶Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊòØÂê¶ËøûÊé•„ÄÇ2.ÈáçÊñ∞ÊâßË°åÂéãÂäõÊ†°ÂáÜ„ÄÇ3.Á°ÆËÆ§Âê∏Ê∞îÂéãÂäõ„ÄÅÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÈááÊ†∑ÁÆ°ÊòØÂê¶ÂÆåÂ•ΩÔºàÊó†Êñ≠Ë£ÇÔºâ‰∏îÊ≠£Á°ÆËøûÊé•„ÄÇ4.Á°ÆËÆ§ÂëºÊ∞îÈòÄ‰æõÁîµÁîµÁ∫øËøûÊé•Ê≠£Á°ÆÔºåÂëºÊ∞îÈòÄÂÆâË£ÖÊ≠£Á°ÆÔºåÈáçÊñ∞ÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ5.Âú®ÈòÄÈó®ËØäÊñ≠ÁïåÈù¢ËØäÊñ≠ÂëºÊ∞îÈòÄÊòØÂê¶ÂºÇÂ∏∏ÔºàÂèÇËßÅÂëºÊ∞îÈòÄÁä∂ÊÄÅÂºÇÂ∏∏ËØäÊñ≠ÔºâÔºåÂ¶ÇÊûúÂºÇÂ∏∏ÔºåÂàôÊõ¥Êç¢ÂëºÊ∞îÈòÄÔºåÂÜçÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ6.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'ÂÆâÂÖ®ÈòÄËá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.YpieceÊ≤°Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊú™ËøûÊé•„ÄÇ2.ÂÆâÂÖ®ÈòÄ‰æõÁîµÂºÇÂ∏∏„ÄÇ3.ÂÆâÂÖ®ÈòÄÂºÇÂ∏∏„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü• Ypiece ÊòØÂê¶Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊòØÂê¶ËøûÊé•„ÄÇ2.Á°ÆËÆ§ÂÆâÂÖ®ÈòÄ‰æõÁîµÁîµÁ∫øËøûÊé•Ê≠£Â∏∏„ÄÇ3.Âú®ÈòÄÈó®ËØäÊñ≠ÁïåÈù¢ËØäÊñ≠ÂÆâÂÖ®ÈòÄÊòØÂê¶ÂºÇÂ∏∏ÔºàÂèÇËßÅ ÂÆâÂÖ®ÈòÄÁä∂ÊÄÅÂºÇÂ∏∏ËØäÊñ≠ÔºâÔºåÂ¶ÇÊûúÂºÇÂ∏∏ÔºåÊõ¥Êç¢ÂÆâÂÖ®ÈòÄÔºåÈáçÊñ∞ÊâßË°åÁ≥ªÁªüËá™Ê£Ä„ÄÇ4.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'Ê≥ÑÊºèÈáèËá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.YpieceÊ≤°Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊú™ËøûÊé•„ÄÇ2.Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÊàñÂéãÂäõ‰º†ÊÑüÂô®ÊµãËØïÂ§±Ë¥•„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü• Ypiece ÊòØÂê¶Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊòØÂê¶ËøûÊé•„ÄÇ2.Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÂíåÂéãÂäõ‰º†ÊÑüÂô®ÊµãËØïÊàêÂäüÂêéÔºåÂÜçËøõË°åÊ≥ÑÊºèÊµãËØï„ÄÇ'},
                           'È°∫Â∫îÊÄßËá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.YpieceÊ≤°Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊú™ËøûÊé•„ÄÇ2.Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÊàñÂéãÂäõ‰º†ÊÑüÂô®ÊµãËØïÂ§±Ë¥•„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü• Ypiece ÊòØÂê¶Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊòØÂê¶ËøûÊé•„ÄÇ2.Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÂíåÂéãÂäõ‰º†ÊÑüÂô®ÊµãËØïÊàêÂäüÂêéÔºåÂÜçËøõË°åÊ≥ÑÊºèÊµãËØï„ÄÇ'},
                           'ÁÆ°Ë∑ØÈòªÂäõËá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.YpieceÊ≤°Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊú™ËøûÊé•„ÄÇ 2.ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÊàñÂéãÂäõ‰º†ÊÑüÂô®ÊµãËØïÂ§±Ë¥•„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü• Ypiece ÊòØÂê¶Â†µ‰ΩèÊàñÁÆ°Ë∑ØÊòØÂê¶ËøûÊé•„ÄÇ2.ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÂíåÂéãÂäõ‰º†ÊÑüÂô®ÊµãËØïÊàêÂäüÂêéÔºåÂÜçËøõË°åÁÆ°Ë∑ØÈòªÂäõÊµãËØï„ÄÇ'},
                           '02‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•':{'ÂéüÂõ†':'1.ÁïåÈù¢Ê∞ßÁõëÊµãÂäüËÉΩÂÖ≥Èó≠„ÄÇ2.Ê∞ß‰º†ÊÑüÂô®Êú™ËøûÊé•ÊàñÊ∞ß‰º†ÊÑüÂô®Â§±Êïà„ÄÇ3.Ê∂°ËΩÆÊµãËØïÊàñO2ÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÊàñÂê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÂ§±Ë¥•„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.ÂºÄÂêØÊ∞ßÁõëÊµãÂäüËÉΩ„ÄÇ2.Á°Æ‰øùÊ∞ß‰º†ÊÑüÂô®ËøûÊé•Ê≠£Á°ÆÔºåÁïåÈù¢Êó†‰ªª‰Ωï‰∏éÊ∞ß‰º†ÊÑüÂô®Áõ∏ÂÖ≥ÁöÑÊä•Ë≠¶ÔºåÈáçÊñ∞ËøõË°åÊ∞ß‰º†ÊÑüÂô®ÊµãËØï„ÄÇ3.Ê∂°ËΩÆÊµãËØï„ÄÅO2 ÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØï„ÄÅÂê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊµãËØïÈÉΩÊàêÂäüÂêéÔºåÂÜçËøõË°åÊ∞ß‰º†ÊÑüÂô®ÊµãËØï„ÄÇ4.ËøõË°å O2 ‰º†ÊÑüÂô®Ê†°ÂáÜ„ÄÇ5.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'WifiÊ®°ÂùóÂ∑•‰ΩúÂºÇÂ∏∏':{'ÂéüÂõ†':'1.WifiÂ§©Á∫øËÑ±ËêΩÊàñÊñ≠Ë£Ç;2.WifiÊ®°ÂùóÊçüÂùè;3.ÁõëÊéß‰∏ªÊùøÂá∫Áé∞ÊïÖÈöú','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.ÈáçÊñ∞ÊèíÊãî wifi Â§©Á∫øÊàñÊõ¥Êç¢Â§©Á∫ø;2.Êõ¥Êç¢ wifi Ê®°Âùó;3.Êõ¥Êç¢ÁõëÊéßÊ®°ÂùóÊùøÂç°ÁªÑ‰ª∂'},
                           '‰∏ªÊµÅC02ÊàñÊóÅÊµÅÊ®°ÂùóÂºÇÂ∏∏':{'ÂéüÂõ†':'1.CO2Ê®°Âùó‰∏éÁõëÊéß‰∏ªÊùøÁöÑËøûÊé•Á∫øÂá∫Áé∞ËÑ±ËêΩÊàñÊñ≠ÂºÄ;2.CO2Ê®°ÂùóËá™Ë∫´ÊïÖÈöú;3.ÁõëÊéßÊ®°Âùó‰∏ªÊùø‰∏≤Âè£ÈÄöËÆØÂá∫Áé∞ÂºÇÂ∏∏','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.ÈáçÊñ∞ÊèíÊãîÊàñÊõ¥Êç¢Áõ∏ÂÖ≥ÁöÑÁ∫øÊùê;2.Êõ¥Êç¢CO2Ê®°Âùó;3.Êõ¥Êç¢ÁõëÊéßÊ®°Âùó‰∏ªÊùøÁªÑ‰ª∂'},
                           'Êó•ÊúüÊó∂Èó¥ÊïÖÈöú':{'ÂéüÂõ†':'ËØ∑ÈáçÊñ∞ËÆæÁΩÆÊó•ÊúüÂíåÊó∂Èó¥ÔºöÁ≥ªÁªü‰∏≠Ê≤°ÊúâÁ∫ΩÊâ£ÁîµÊ±†ÔºåÊàñÁîµÊ±†‰∏≠Ê≤°ÊúâÁîµÈáè„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Êõ¥Êç¢Á∫ΩÊâ£ÁîµÊ±†ÔºåÂπ∂ÈáçÊñ∞ËÆæÁΩÆÊó•ÊúüÂíåÊó∂Èó¥„ÄÇ2.ÊïÖÈöú‰ªçÂ≠òÂú®ÔºåÈúÄÊõ¥Êç¢‰∏ªÊéßÊùø„ÄÇ'},
                           'ÂëºÊú´Ê≠£ÂéãËøáÈ´ò': {'ÂéüÂõ†': 'ÂëºÊú´Ê≠£ÂéãÁõëÊµãÂÄºÈ´ò‰∫éPEEPËÆæÁΩÆÂÄº+5cmH2O„ÄÇ','Ëß£ÂÜ≥ÊñπÊ≥ï': '1.ÂèÇËßÅÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÂéãÂäõ‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ2.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆ„ÄÇ'},
                           'ÂëºÊú´Ê≠£ÂéãËøá‰Ωé': {'ÂéüÂõ†': 'ÂëºÊú´Ê≠£ÂéãÁõëÊµãÂÄºÈ´ò‰∫éPEEPËÆæÁΩÆÂÄº+5cmH2O„ÄÇ','Ëß£ÂÜ≥ÊñπÊ≥ï': '1. ÂèÇËßÅÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÂéãÂäõ‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ2.Ê£ÄÊü•ÂëºÊ∞îÈòÄÂÆâË£ÖÊòØÂê¶Ê≠£Á°ÆÔºõ 3.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆ„ÄÇ'},
                           'ÁÆ°ÈÅìÂ†µÂ°û': {'ÂéüÂõ†': 'ÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØÂá∫Áé∞ÈòªÂ°û', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØÊòØÂê¶ÊúâÈòªÂ°ûÔºåÂ¶ÇÊûúÊúâÔºåËØ∑ÁñèÈÄöÔºõ 2.ÂèÇËßÅÊµÅÈáè‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ 3. ÂèÇËßÅ ÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÂéãÂäõ‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜ„ÄÇ'},
                           'Âê∏Ê∞îÊîØË∑ØÁÆ°ÈÅìÂ†µÂ°û': {'ÂéüÂõ†': 'Ê∞ßÁñóÊó∂ÔºåÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØÂá∫Áé∞ÂºØÊäòÊàñÈòªÂ°û;', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØÊòØÂê¶ÊúâÈòªÂ°ûÊàñÂºØÊäòÔºåÂ¶ÇÊûúÊúâÔºåËØ∑ÁñèÈÄöÔºõ2.ÂèÇËßÅÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•Âê∏Ê∞îÂéãÂäõ‰º†ÊÑüÂô®„ÄÇÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜ„ÄÇ'},
                           'Ê∞îÈÅìÂéãÂäõËøáÈ´ò': {'ÂéüÂõ†': 'ÁóÖ‰∫∫Ê∞îÈÅìÂéãÂäõÊåÅÁª≠Âú®‰∏Ä‰∏™ËæÉÈ´òÊ∞¥Âπ≥', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆÔºõ2. ÂèÇËßÅÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÂéãÂäõ‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜ'},
                           'ÁÆ°ÈÅìÊ≥ÑÊºè': {'ÂéüÂõ†': 'ÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØÂá∫Áé∞‰∫ÜÊ≥ÑÊºè', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØÊòØÂê¶ÊúâÊ≥ÑÊºèÔºåÂ¶ÇÊûúÊ≥ÑÊºèËØ∑Êõ¥Êç¢ÁÆ°Ë∑ØÔºõ2. ÂèÇËßÅÊµÅÈáè‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ 3. ÂèÇËßÅÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÂéãÂäõ‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜ„ÄÇ'},
                           'ÁÆ°ÈÅìÊñ≠ÂºÄ': {'ÂéüÂõ†': 'ÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØËÑ±ËêΩ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÁóÖ‰∫∫Á´ØÁÆ°Ë∑ØÊòØÂê¶ËÑ±ËêΩÊàñÊùæÂä®ÔºåÂ¶ÇÊûúÊúâÔºåËØ∑ÈáçÊñ∞ËøûÊé•Ôºõ 2. ÂèÇËßÅ ÊµÅÈáè‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ3. ÂèÇËßÅÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÂéãÂäõ‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜ„ÄÇ'},
                           'ÂéãÂäõÈôêÂà∂': {'ÂéüÂõ†': 'ÂéãÂäõËææÂà∞ÂéãÂäõÊä•Ë≠¶È´òÈôê-5cmH2O', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆÔºåÂåÖÊã¨ÂéãÂäõÊä•Ë≠¶È´òÈôêËÆæÁΩÆÔºõ2.Ê£ÄÊü•ÊòØÂê¶ÊúâÂéãÂäõ‰º†ÊÑüÂô®ÊïÖÈöúÊä•Ë≠¶ÔºàÂØπÂ∫îÊä•Ë≠¶Â≠óÁ¨¶‰∏≤‰∏∫‚ÄúÊú∫Âô®ÊïÖÈöú 09‚ÄùÂíå‚ÄúÊú∫Âô®ÊïÖÈöú 21‚ÄùÔºâÔºåÂ¶ÇÊûúÊïÖÈöúËØ∑Êõ¥Êç¢Ôºõ 3.Â¶ÇÊûúÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåËØ∑Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'ÂÆπÈáèÈôêÂà∂': {'ÂéüÂõ†': 'ÂéãÂäõÊ®°Âºè‰∏ãÔºåÈÄÅÊ∞îË∂ÖËøáËÆæÂÆöÊΩÆÊ∞îÈáè‰∏äÈôêÔºåÊèêÂâçËΩ¨‰∏∫ÂëºÊ∞î', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆÔºåÂåÖÊã¨ÂëºÂá∫ÊΩÆÊ∞îÈáèÊä•Ë≠¶È´òÈôêËÆæÁΩÆÔºõ 2.Ê£ÄÊü•ÊòØÂê¶Êúâ‚ÄúËØ∑Ê£ÄÊü•ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®‚ÄùÊä•Ë≠¶ÔºåÂ¶ÇÊûúÊúâËØ•Êä•Ë≠¶ÔºåËØ∑ÂÖàÊéíÈô§ËØ•Êä•Ë≠¶Ôºõ3.Â¶ÇÊûúÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåËØ∑Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'Âê∏Ê∞îÂéãÂäõÊú™ËææÂà∞': {'ÂéüÂõ†': 'Ê∞îÈÅìÂ≥∞ÂéãÊ≤°ÊúâËææÂà∞ËÆæÂÆöÂÄº', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÁÆ°ÈÅìÊòØÂê¶Ê≥ÑÊºèÔºåÂ¶ÇÊûúÊúâÔºåËØ∑ÈáçÊñ∞ËøûÊé•Ôºõ 2. ÂèÇËßÅÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÂéãÂäõ‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ 3.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆ„ÄÇ '},
                           'ÂëºÂá∫ÊΩÆÊ∞îÈáèËøá‰Ωé': {'ÂéüÂõ†': 'ÊΩÆÊ∞îÈáèÊ≤°ÊúâËææÂà∞ËÆæÂÆöÂÄº','Ëß£ÂÜ≥ÊñπÊ≥ï': '1.Ê£ÄÊü•ÁÆ°ÈÅìÊòØÂê¶Ê≥ÑÊºèÔºåÂ¶ÇÊûúÊúâÔºåËØ∑ÈáçÊñ∞ËøûÊé•Ôºõ2. ÂèÇËßÅÊµÅÈáè‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ3.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆÊòØÂê¶ÂêàÁêÜ„ÄÇ '},
                           'ÊΩÆÊ∞îÈáèÊú™ËææÂà∞': {'ÂéüÂõ†': 'ÊΩÆÊ∞îÈáèÊ≤°ÊúâËææÂà∞ËÆæÂÆöÂÄº','Ëß£ÂÜ≥ÊñπÊ≥ï': '1.Ê£ÄÊü•ÁÆ°ÈÅìÊòØÂê¶Ê≥ÑÊºèÔºåÂ¶ÇÊûúÊúâÔºåËØ∑ÈáçÊñ∞ËøûÊé•Ôºõ2. ÂèÇËßÅÊµÅÈáè‰º†ÊÑüÂô®ÊµãÈáèÂáÜÁ°ÆÊÄßÁöÑÊ£ÄÊµãÁ´†ËäÇÔºåÊ£ÄÊü•ÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÂáÜÔºåËØ∑ÈáçÊñ∞Ê†°ÂáÜÔºõ3.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆÊòØÂê¶ÂêàÁêÜ„ÄÇ '},
                           'ÂèπÊÅØÂë®ÊúüÂéãÂäõÈôêÂà∂': {'ÂéüÂõ†': 'ÂèπÊÅØÂäüËÉΩÂêØÂä®ÂêéÔºåÂèπÊÅØÂë®ÊúüÁöÑÂéãÂäõËææÂà∞ÂéãÂäõÊä•Ë≠¶È´òÈôê-5cmH2O', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆÔºåÂåÖÊã¨ÂéãÂäõÊä•Ë≠¶È´òÈôêËÆæÁΩÆÔºõ2.Ê£ÄÊü•ÊòØÂê¶ÊúâÂéãÂäõ‰º†ÊÑüÂô®ÊïÖÈöúÊä•Ë≠¶ÔºàÂØπÂ∫îÊä•Ë≠¶Â≠óÁ¨¶‰∏≤‰∏∫‚ÄúÊú∫Âô®ÊïÖÈöú 09‚ÄùÂíå‚ÄúÊú∫Âô®ÊïÖÈöú 21‚ÄùÔºâÔºåÂ¶ÇÊûúÊïÖÈöúËØ∑Êõ¥Êç¢Ôºõ 3.Â¶ÇÊûúÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåËØ∑Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'Ê∞ßÊ∞î‰∏çË∂≥': {'ÂéüÂõ†':'Ê∞ßÊ∞î‰æõÂ∫î‰∏çÂÖÖË∂≥', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÊòØÂê¶ËøûÊé•È´òÂéãÊ∞ßÊ∞îÊ∫êÔºå‰∏îÊ∞îÊ∫êÊòØÂê¶ÂÖÖË∂≥Ôºõ 2.Âú®ÈòÄÈó®ËØäÊñ≠ÁïåÈù¢ËØäÊñ≠Ê∞ßÊ∞îÊØî‰æãÈòÄÊòØÂê¶ÂºÇÂ∏∏ÔºàÂèÇËßÅÂê∏Ê∞îÈòÄÊàñÊ∞ßÊ∞îÊØî‰æãÈòÄÁä∂ÊÄÅÂºÇÂ∏∏ËØäÊñ≠ÔºâÔºåÂ¶ÇÊûúÂºÇÂ∏∏Êõ¥Êç¢Ê∞ßÊ∞îÊØî‰æãÈòÄ3.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'Âê∏Ê∞îÊó∂Èó¥ËøáÈïø': {'ÂéüÂõ†':'PSV Ê®°ÂºèËá™‰∏ªÂëºÂê∏‰∏ÄÁõ¥‰∏çÊª°Ë∂≥ÂëºÊ∞îÁÅµÊïèÂ∫¶ËÄå‰ΩøÂæóÂê∏Ê∞îËøáÁ®ã‰∏çËÉΩÁªìÊùü„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÂèÇÊï∞ËÆæÁΩÆÔºõ2.Ê£ÄÊü•Âπ∂Êõ¥Êç¢ÂéãÂäõÂíåÊµÅÈáè‰º†ÊÑüÂô®„ÄÇ'},
                           'ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÊïÖÈöú': {'ÂéüÂõ†':'ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÊïÖÈöú','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê†°Èõ∂ÔºåÂèÇËßÅÂéãÂäõÂíåÊµÅÈáèÊ†°Èõ∂Ôºõ 2.Ê†°ÂáÜÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂèÇËßÅÊµÅÈáèÊ†°ÂáÜÔºõ 3.Êõ¥Êç¢ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®„ÄÇ '},
                           'Âê∏ÂÖ•Ê∞î‰ΩìÊ∏©Â∫¶ËøáÈ´ò': {'ÂéüÂõ†':'Âê∏ÂÖ•Ê∞î‰ΩìÊ∏©Â∫¶Ë∂ÖËøáÈôêÂà∂','Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü•Êú∫Âô®Â∑•‰ΩúÁéØÂ¢ÉÊ∏©Â∫¶ÊòØÂê¶Ë∂ÖËøáÂéÇÂÆ∂Â£∞Áß∞ÊúÄÂ§ßÂ∑•‰ΩúÊ∏©Â∫¶ 40‚ÑÉÔºõ 2.Ê£ÄÊü•È£éÊâáÂÖ•Âè£„ÄÅÂá∫È£éÂè£ÊòØÂê¶Ë¢´Â†µÔºåÂ¶ÇÊûúË¢´Â†µÔºåÊ∏ÖÁêÜÂºÇÁâ©ÂíåÁÅ∞Â∞òÔºõÊ£ÄÊü•È£éÊâáËøêËΩ¨ÊÉÖÂÜµÔºåÂ¶ÇÊûúÂºÇÂ∏∏ÔºàÂ¶ÇÂºÇÂìç„ÄÅËΩ¨ÈÄü‰∏çÊ≠£Â∏∏Á≠âÔºâÔºåÂàôÊõ¥Êç¢È£éÊâáÔºõ 3.Âú® A/D ÈÄöÈÅì‰∏≠ÔºåÊ£ÄÊü•Âê∏ÂÖ•Ê∑∑ÂêàÊ∞î‰ΩìÂíåÂê∏ÂÖ•Ê∞ßÊ∞îÁöÑÊ∏©Â∫¶ÊµãÈáèÂÄºÊòØÂê¶Ë∂ÖÂá∫ A/D ÈÄöÈÅìÊèê‰æõÁöÑËåÉÂõ¥ÔºåÊõ¥Êç¢ÂØπÂ∫îÊ∏©Â∫¶Ë∂ÖÈôêÁöÑÊµÅÈáè‰º†ÊÑüÂô®ÔºàÊ∑∑ÂêàÊ∞î‰ΩìÊµÅÈáè‰º†ÊÑüÂô®ÊàñÊ∞ßÊ∞îÊµÅÈáè‰º†ÊÑüÂô®Ôºâ'},
                           'Ê∞ß‰º†ÊÑüÂô®Êú™ËøûÊé•': {'ÂéüÂõ†':'Ê≤°ÊúâËøûÊé•Ê∞ß‰º†ÊÑüÂô®', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'1.Ê£ÄÊü•Ê∞ß‰º†ÊÑüÂô®ÁîµÁºÜÊòØÂê¶ËÑ±ËêΩÔºåÂ¶ÇÊûúËÑ±ËêΩÔºåËØ∑ÈáçÊñ∞ËøûÊé•„ÄÇ2.Â¶ÇÊûúÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåÊõ¥Êç¢Ê∞ß‰º†ÊÑüÂô®„ÄÇ'},
                           'ËØ∑Êõ¥Êç¢Ê∞ß‰º†ÊÑüÂô®': {'ÂéüÂõ†':'Ê∞ß‰º†ÊÑüÂô®Áî®Â∞Ω', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'Êõ¥Êç¢Ê∞ß‰º†ÊÑüÂô®'},
                           'ËØ∑Ê†°ÂáÜÊ∞ß‰º†ÊÑüÂô®': {'ÂéüÂõ†':'Ê∞ß‰º†ÊÑüÂô®Êú™ËøõË°åÊ†°ÂáÜ','Ëß£ÂÜ≥ÂäûÊ≥ï':'ÈáçÊñ∞ËøõË°å21%Âíå100%Ê∞ß‰º†ÊÑüÂô®Ê†°ÂáÜÔºåÂèÇËßÅO2%Ê†°ÂáÜ'},
                           'ËØ∑ËøõË°åÂéãÂäõÊ†°ÂáÜ': {'ÂéüÂõ†': 'ÂéãÂäõ‰º†ÊÑüÂô®Ê≤°ÊúâËøõË°åÊ†°ÂáÜ','Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ËøõË°åÂéãÂäõ‰º†ÊÑüÂô®Ê†°ÂáÜÔºåÂèÇËßÅÂéãÂäõÊ†°ÂáÜÔºàÂéÇÂÆ∂Ôºâ„ÄÇ2.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'ËØ∑ËøõË°åÊµÅÈáèÊ†°ÂáÜ': {'ÂéüÂõ†': 'ÊµÅÈáè‰º†ÊÑüÂô®ÂíåÂê∏Ê∞îÈòÄÊ≤°ÊúâËøõË°åÊ†°ÂáÜ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ËøõË°åÊµÅÈáè‰º†ÊÑüÂô®ÂíåÂê∏Ê∞îÈòÄÊ†°ÂáÜÔºåÂèÇËßÅÊµÅÈáèÊ†°ÂáÜÔºàÂéÇÂÆ∂ÔºâÁ´†ËäÇ„ÄÇ2.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'ÊµÅÈáè‰º†ÊÑüÂô®Á±ªÂûãÈîôËØØ': {'ÂéüÂõ†': 'Á©∫Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÊàñÊ∞ßÊ∞îÊµÅÈáè‰º†ÊÑüÂô®Á±ªÂûãÈîô', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•Ê∑∑ÂêàÊ∞î‰ΩìÊµÅÈáè‰º†ÊÑüÂô®ÊòØÂê¶ÊòØÁ©∫Ê∞îÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÊòØÔºåËØ∑Êõ¥Êç¢„ÄÇ 2.Ê£ÄÊü•Ê∞ßÊ∞îÊîØË∑ØÊµÅÈáè‰º†ÊÑüÂô®ÊòØÂê¶ÊòØÊ∞ßÊ∞îÊµÅÈáè‰º†ÊÑüÂô®ÔºåÂ¶ÇÊûú‰∏çÊòØÔºåËØ∑Êõ¥Êç¢„ÄÇ '},
                           'Ê∂°ËΩÆÊ∏©Â∫¶ËøáÈ´ò': {'ÂéüÂõ†': 'Ê∂°ËΩÆÊ∏©Â∫¶Ë∂ÖËøá‰∏ÄÂÆöÈòàÂÄº', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•Êú∫Âô®Â∑•‰ΩúÁéØÂ¢ÉÊ∏©Â∫¶ÊòØÂê¶Ë∂ÖËøáÂéÇÂÆ∂Â£∞Áß∞ÊúÄÂ§ßÂ∑•‰ΩúÊ∏©Â∫¶40‚ÑÉ„ÄÇ2.Ê£ÄÊü•È£éÊâáÂÖ•Âè£„ÄÅÂá∫È£éÂè£ÊòØÂê¶Ë¢´Â†µÔºåÂ¶ÇÊûúË¢´Â†µÔºåÊ∏ÖÁêÜÂºÇÁâ©ÂíåÁÅ∞Â∞òÔºõÊ£ÄÊü•È£éÊâáËøêËΩ¨ÊÉÖÂÜµÔºåÂ¶ÇÊûúÂºÇÂ∏∏ÔºàÂ¶ÇÂºÇÂìç„ÄÅËΩ¨ÈÄü‰∏çÊ≠£Â∏∏Á≠âÔºâÔºåÂàôÊõ¥Êç¢È£éÊâá„ÄÇ'},
                           'ÁîµÊ±†Ê∏©Â∫¶ËøáÈ´ò': {'ÂéüÂõ†':'ÁîµÊ±†ÊîæÁîµËøáÁ®ã‰∏≠Ê∏©Â∫¶ÂÅèÈ´ò', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Á°ÆËÆ§‰ΩøÁî®ÁéØÂ¢ÉÊ∏©Â∫¶ÊòØÂê¶ËøáÈ´òÔºåÊØîÂ¶ÇË∂ÖËøá 35‚ÑÉÔºåÂ¶ÇÊûúË∂ÖËøáÔºåÂàôÂª∫ËÆÆÂÆ¢Êà∑Âú®Êõ¥‰ΩéÁöÑÁéØ Â¢ÉÊ∏©Â∫¶‰∏≠‰ΩøÁî®ÔºåÂπ∂‰øùËØÅÊú∫Âô®ÈôÑËøëÊ≤°ÊúâÂèëÁÉ≠Ê∫êÔºõ 2.Ê£ÄÊü•È£éÊâáÂÖ•Âè£„ÄÅÂá∫È£éÂè£ÊòØÂê¶Ë¢´Â†µÔºåÂ¶ÇÊûúË¢´Â†µÔºåÊ∏ÖÁêÜÂºÇÁâ©ÂíåÁÅ∞Â∞òÔºõÊ£ÄÊü•È£éÊâáËøêËΩ¨ÊÉÖÂÜµÔºå Â¶ÇÊûúÂºÇÂ∏∏ÔºàÂ¶ÇÂºÇÂìç„ÄÅËΩ¨ÈÄü‰∏çÊ≠£Â∏∏Á≠âÔºâÔºåÂàôÊõ¥Êç¢È£éÊâáÔºõ3.Ëã•‰ª•‰∏ä2Êù°ÂùáÊéíÈô§ÔºåÂàôÊ£ÄÊü•ÁîµÊ±†ÊòØÂê¶Ê≠£Â∏∏4.ÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®ÔºåËØ∑Êõ¥Êç¢ DC-DC Êùø'},
                           'ÊäÄÊúØÈîôËØØ01': {'ÂéüÂõ†': 'ÊåâÈîÆÊùøÈÄöËÆØÂÅúÊ≠¢', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÊåâÈîÆÊùøÂíå‰∏ªÊéßÊùøÊé•Âè£ÊòØÂê¶Êé•Ëß¶‰∏çËâØÔºåÂ¶ÇÊûúÊòØÔºåËØ∑ÈáçÊñ∞ÊãîÊèíÊàñËÄÖÊõ¥Êç¢ÈÄöËÆØÁ∫ø„ÄÇ2.ÊïÖÈöú‰ªçÂ≠òÂú®ÔºåÊ£ÄÊü•ÊåâÈîÆÊùøËΩØ‰ª∂ÁöÑÊ≠£Á°ÆÊÄß„ÄÇ3.ÊïÖÈöú‰ªçÂ≠òÂú®ÔºåÊõ¥Êç¢ÊåâÈîÆÊùøÊùøÂç°„ÄÇ4.ÊïÖÈöú‰ªçÂ≠òÂú®ÔºåÊõ¥Êç¢‰∏ªÊéßÊùøÊùøÂç°'},
                           'ÊäÄÊúØÈîôËØØ02': {'ÂéüÂõ†': 'ÊåâÈîÆÊùøËá™Ê£ÄÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÊú∫Âô®„ÄÇ2.Êõ¥Êç¢ÊåâÈîÆÊùøËΩØ‰ª∂„ÄÇ3.Â¶ÇÊûúÊïÖÈöú‰∏çËÉΩËß£ÂÜ≥ÔºåÊõ¥Êç¢ÊåâÈîÆÊùø'},
                           'ÊäÄÊúØÈîôËØØ03': {'ÂéüÂõ†':'Ê∂°ËΩÆÊ∏©Â∫¶‰º†ÊÑüÂô®ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Âú®A/DÈÄöÈÅìÊü•ÁúãÊ∂°ËΩÆÂÜÖÈÉ®Ê∏©Â∫¶ÂíåÊ∂°ËΩÆÂ§ñÈÉ®Ê∏©Â∫¶ÔºåÂ¶ÇÊûúÂÜÖÈÉ®Ê∏©Â∫¶ÔºàÊàñÂ§ñÈÉ®Ê∏©Â∫¶ÔºâË∂ÖÈôêÔºåÊõ¥Êç¢ËØ•Ê∏©Â∫¶‰º†ÊÑüÂô®„ÄÇ'},
                           'ÊäÄÊúØÈîôËØØ05': {'ÂéüÂõ†': 'ÁéØÂ¢ÉÂ§ßÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÊòØÂê¶ÂêåÊó∂Â≠òÂú®‚ÄúÊäÄÊúØÈîôËØØ 06‚ÄùÊä•Ë≠¶ÔºåÂ¶ÇÊûúÂ≠òÂú®ÔºåÂú® A/D ÈÄöÈÅìÊü•Áúã‚ÄúPfilter ÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂéãÂäõÂÄº‚ÄùÂíå‚ÄúÂ§ßÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂ§ßÊ∞îÂéã‚ÄùÂì™‰∏™Êï∞ÂÄºÊõ¥Êé•ËøëÂΩìÂâçÁéØÂ¢ÉÂ§ßÊ∞îÂéãÔºåÊõ¥Êç¢ÂÅèÂ∑ÆËæÉÂ§ßÁöÑ‰º†ÊÑüÂô®„ÄÇ2.Êõ¥Êç¢ÁõëÊéßÊùø'},
                           'ÊäÄÊúØÈîôËØØ06': {'ÂéüÂõ†': 'HEPA ËøáÊª§Âô®ÂéãÂäõ‰º†ÊÑüÂô®ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÊòØÂê¶ÂêåÊó∂Â≠òÂú®‚ÄúÊäÄÊúØÈîôËØØ 05‚ÄùÊä•Ë≠¶ÔºåÂ¶ÇÊûúÂ≠òÂú®ÔºåÂú® A/D ÈÄöÈÅìÊü•Áúã‚ÄúPfilter ÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂéãÂäõÂÄº‚ÄùÂíå‚ÄúÂ§ßÊ∞îÂéãÂäõ‰º†ÊÑüÂô®ÊµãÈáèÂ§ßÊ∞îÂéã‚ÄùÂì™‰∏™Êï∞ÂÄºÊõ¥Êé•ËøëÂΩìÂâçÁéØÂ¢ÉÂ§ßÊ∞îÂéãÔºåÊõ¥Êç¢ÂÅèÂ∑ÆËæÉÂ§ßÁöÑ‰º†ÊÑüÂô®Ôºõ2.Êõ¥Êç¢ÁõëÊéßÊùø'},
                           'ÊäÄÊúØÈîôËØØ07': {'ÂéüÂõ†': '‰∏âÈÄöÈòÄÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Ê£ÄÊü•‰∏âÈÄöÈòÄÔºåÂπ∂Êõ¥Êç¢'},
                           'ÊäÄÊúØÈîôËØØ08': {'ÂéüÂõ†': 'ÈõæÂåñÈòÄÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Ê£ÄÊü•ÈõæÂåñÈòÄÔºåÂπ∂Êõ¥Êç¢'},
                           'ÊäÄÊúØÈîôËØØ09': {'ÂéüÂõ†': 'Âê∏ÂÖ•Ê∏©Â∫¶‰º†ÊÑüÂô®ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Âú® A/D ÈÄöÈÅì‰∏≠ÔºåÊ£ÄÊü•Âê∏ÂÖ•Ê∑∑ÂêàÊ∞î‰ΩìÂíåÂê∏ÂÖ•Ê∞ßÊ∞îÁöÑÊ∏©Â∫¶ÊµãÈáèÂÄºÊòØËøáÂ§ßÊàñËøáÂ∞èÔºåÊõ¥Êç¢Â≠òÂú®ÈóÆÈ¢òÁöÑÊ∏©Â∫¶‰º†ÊÑüÂô®Ôºõ2. Êõ¥Êç¢Âê∏ÂÖ•Ê∑∑ÂêàÊ∞î‰ΩìÊ∏©Â∫¶‰º†ÊÑüÂô®ÂíåÂê∏ÂÖ•Ê∞ßÊ∞îÊ∏©Â∫¶‰º†ÊÑüÂô®'},
                           'Êú∫Âô®ÊïÖÈöú01': {'ÂéüÂõ†': 'Êú∫Âô®ÂÜÖÈÉ®ÁîµÂéãÂºÇÂ∏∏', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÊµãÈáèÁõ∏Â∫îÊµãËØïÁÇπÁîµÂéãÔºõ2.ÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®Êõ¥Êç¢ÁîµÊ∫êÊùø'},
                           'Êú∫Âô®ÊïÖÈöú02': {'ÂéüÂõ†': 'ÂÜÖÂ≠òÂºÇÂ∏∏', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÂëºÂê∏Êú∫Ôºõ2.ÊïÖÈöú‰ªçÁÑ∂Â≠òÂú®Êõ¥Êç¢ÁõëÊéßÊùø'},
                           'Êú∫Âô®ÊïÖÈöú03': {'ÂéüÂõ†': 'ÁîµÊ∫êÊùøËá™Ê£ÄÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÂëºÂê∏Êú∫Ôºõ2.Êõ¥Êç¢ÁîµÊ∫êÊùøËΩØ‰ª∂Ôºõ3.Â¶ÇÊûúÊïÖÈöú‰∏çËÉΩËß£ÂÜ≥ÔºåÊõ¥Êç¢ÁîµÊ∫êÊùø'},
                           'Êú∫Âô®ÊïÖÈöú04': {'ÂéüÂõ†': 'ÁõëÊéßÊ®°ÂùóÂàùÂßãÂåñÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Ê£ÄÊü•ÁõëÊéßÊùøÁ°¨‰ª∂ÔºåÂ¶ÇÊûúÊïÖÈöúËØ∑Êõ¥Êç¢'},
                           'Êú∫Âô®ÊïÖÈöú05': {'ÂéüÂõ†': 'ÁõëÊéßÊ®°ÂùóÈÄöËÆØÂÅúÊ≠¢', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÁõëÊéßÊùøÂíå‰∏ªÊéßÊùøÊé•Âè£ÊòØÂê¶Êé•Ëß¶‰∏çËâØÔºåÂ¶ÇÊûúÊòØÔºåËØ∑ÈáçÊñ∞ÊãîÊèíÊàñËÄÖÊõ¥Êç¢ÈÄöËÆØÁ∫øÔºõ2.Ê£ÄÊü•ÁõëÊéßÊ®°ÂùóÊòØÂê¶ÊçüÂùèÔºåÂ¶ÇÊûúÊçüÂùèÔºåËØ∑Êõ¥Êç¢ÁõëÊéßÊ®°ÂùóÔºõ3.Ê£ÄÊü•‰∏ªÊéßÊùøÊòØÂê¶ÊçüÂùèÔºåÂ¶ÇÊûúÊçüÂùèÔºåËØ∑Êõ¥Êç¢‰∏ªÊéßÊùøÔºõ4.Ê£ÄÊü•ËΩØ‰ª∂ÁâàÊú¨ÊòØÂê¶ÂÖºÂÆπÔºåËã•‰∏çÂÖºÂÆπÔºåËØ∑ÈáçÊñ∞ÂçáÁ∫ßÊ≠£Á°ÆÁöÑËΩØ‰ª∂ÁâàÊú¨„ÄÇ'},
                           'Êú∫Âô®ÊïÖÈöú06': {'ÂéüÂõ†': 'ÁõëÊéßÊ®°ÂùóËá™Ê£ÄÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÂëºÂê∏Êú∫Ôºõ2.Ê£ÄÊü•Âπ∂Êõ¥Êç¢ÁõëÊéßÊ®°Âùó'},
                           'Êú∫Âô®ÊïÖÈöú07': {'ÂéüÂõ†': 'Âê∏Ê∞îÊ®°ÂùóÈÄöËÆØÂÅúÊ≠¢', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÂëºÂê∏Êú∫Ôºõ2.ÂçáÁ∫ßÂê∏Ê∞îÊ®°ÂùóËΩØ‰ª∂ÂíåÁõëÊéßÊ®°ÂùóËΩØ‰ª∂'},
                           'Êú∫Âô®ÊïÖÈöú08': {'ÂéüÂõ†': 'ÂëºÊ∞îÊ®°ÂùóÈÄöËÆØÂÅúÊ≠¢', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÂëºÂê∏Êú∫Ôºõ2.ÂçáÁ∫ßÂëºÊ∞îÊ®°ÂùóËΩØ‰ª∂ÂíåÁõëÊéßÊ®°ÂùóËΩØ‰ª∂'},
                           'Êú∫Âô®ÊïÖÈöú09': {'ÂéüÂõ†': 'ÂéãÂäõ‰º†ÊÑüÂô®ÈÄöËÆØÂÅúÊ≠¢', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Êõ¥Êç¢Âê∏Ê∞îÂéãÂäõ‰º†ÊÑüÂô®Ôºõ2.Êõ¥Êç¢ÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®'},
                           'Êú∫Âô®ÊïÖÈöú10': {'ÂéüÂõ†': 'ÂÆâÂÖ®ÈòÄÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Ê£ÄÊü•ÂÆâÂÖ®ÈòÄÔºåÂπ∂Êõ¥Êç¢'},
                           'Êú∫Âô®ÊïÖÈöú12': {'ÂéüÂõ†': 'Âê∏Ê∞îÊîØË∑ØÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•Âê∏Ê∞îÈòÄÊòØÂê¶Â∑•‰ΩúÊ≠£Â∏∏ÔºåÂ¶ÇÊûúÂ∑•‰Ωú‰∏çÊ≠£Â∏∏ÔºåËØ∑Êõ¥Êç¢Âê∏Ê∞îÈòÄÔºõ2.Ê£ÄÊü•Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®Ôºõ3.Êõ¥Êç¢Âê∏Ê∞îÈòÄÊàñËÄÖÂê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®Âπ∂Ê†°ÂáÜ'},
                           'Êú∫Âô®ÊïÖÈöú13': {'ÂéüÂõ†': 'O2ÊîØË∑ØÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•Ê∞ßÊ∞îÊØî‰æãÈòÄÊòØÂê¶Â∑•‰ΩúÊ≠£Â∏∏ÔºåÂ¶ÇÊûúÂ∑•‰Ωú‰∏çÊ≠£Â∏∏ÔºåËØ∑Êõ¥Êç¢Ê∞ßÊ∞îÊØî‰æãÈòÄÔºõ2.Ê£ÄÊü•Ê∞ßÊ∞îÊµÅÈáè‰º†ÊÑüÂô®Ôºõ3.Êõ¥Êç¢Ê∞ßÊ∞îÊØî‰æãÈòÄÊàñËÄÖÊ∞ßÊ∞îÊµÅÈáè‰º†ÊÑüÂô®Âπ∂Ê†°ÂáÜ'},
                           'Êú∫Âô®ÊïÖÈöú14': {'ÂéüÂõ†':'Ê∂°ËΩÆÂ§±Êïà', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢Ê∂°ËΩÆ'},
                           'Êú∫Âô®ÊïÖÈöú15': {'ÂéüÂõ†': 'Ê∂°ËΩÆÊ∏©Â∫¶ËøáÈ´ò', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•Êú∫Âô®Â∑•‰ΩúÁéØÂ¢ÉÊ∏©Â∫¶ÊòØÂê¶Ë∂ÖËøáÂ∑•‰ΩúÊ∏©Â∫¶Ôºõ2.Ê£ÄÊü•È£éÊâáÂÖ•Âè£„ÄÅÂá∫È£éÂè£ÊòØÂê¶Ë¢´Â†µÔºåÂ¶ÇÊûúË¢´Â†µÔºåÊ∏ÖÁêÜÂºÇÁâ©ÂíåÁÅ∞Â∞òÔºõÊ£ÄÊü•È£éÊâáËøêËΩ¨ÊÉÖÂÜµÔºåÂ¶ÇÊûúÂºÇÂ∏∏ÔºàÂ¶ÇÂºÇÂìç„ÄÅËΩ¨ÈÄü‰∏çÊ≠£Â∏∏Á≠âÔºâÔºåÂàôÊõ¥Êç¢È£éÊâá'},
                           'Êú∫Âô®ÊïÖÈöú16': {'ÂéüÂõ†': 'Âê∏Ê∞îÈòÄËÑ±ËêΩ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•Âê∏Ê∞îÈòÄËøûÊé•ÊÉÖÂÜµÔºõ2.Êõ¥Êç¢Âê∏Ê∞îÈòÄ„ÄÇ'},
                           'Êú∫Âô®ÊïÖÈöú17': {'ÂéüÂõ†': 'Âê∏Ê∞îÊ®°ÂùóËá™Ê£ÄÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÂëºÂê∏Êú∫Ôºõ2.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'Êú∫Âô®ÊïÖÈöú18': {'ÂéüÂõ†': 'Âê∏Ê∞îÊ®°ÂùóËá™Ê£ÄÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.ÈáçÂêØÂëºÂê∏Êú∫Ôºõ2.Êõ¥Êç¢ÁõëÊéßÊùø„ÄÇ'},
                           'Êú∫Âô®ÊïÖÈöú19': {'ÂéüÂõ†': 'ÁîµÊ∫êÊùøÈÄöËÆØÂÅúÊ≠¢', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•ÁîµÊ∫êÊùøÂíå‰∏ªÊéßÊùøÊé•Âè£ÊòØÂê¶Êé•Ëß¶‰∏çËâØÔºåÂ¶ÇÊûúÊòØÔºåËØ∑ÈáçÊñ∞ÊãîÊèíÊàñËÄÖÊõ¥Êç¢ÈÄöËÆØÁ∫øÔºõ2.Ê£ÄÊü•ÁîµÊ∫êÊùøÊòØÂê¶ÊçüÂùèÔºåÂ¶ÇÊûúÊçüÂùèÔºåËØ∑Êõ¥Êç¢ÁîµÊ∫êÊùøÔºõ3.Ê£ÄÊü•‰∏ªÊéßÊùøÊòØÂê¶ÊçüÂùèÔºåÂ¶ÇÊûúÊçüÂùèÔºåËØ∑Êõ¥Êç¢‰∏ªÊéßÊùøÔºõ4.Ê£ÄÊü•ËΩØ‰ª∂ÁâàÊú¨ÊòØÂê¶ÂÖºÂÆπÔºåËã•‰∏çÂÖºÂÆπÔºåËØ∑ÈáçÊñ∞ÂçáÁ∫ßÊ≠£Á°ÆÁöÑËΩØ‰ª∂ÁâàÊú¨'},
                           'Êú∫Âô®ÊïÖÈöú21': {'ÂéüÂõ†': 'ÂéãÂäõ‰º†ÊÑüÂô®Èõ∂ÁÇπÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Êõ¥Êç¢Âê∏Ê∞îÂéãÂäõ‰º†ÊÑüÂô®„ÄÇ2.Êõ¥Êç¢ÂëºÊ∞îÂéãÂäõ‰º†ÊÑüÂô®'},
                           'Êú∫Âô®ÊïÖÈöú22': {'ÂéüÂõ†': '‰øùÊä§Ê®°ÂùóÈÄöËÆØÂÅúÊ≠¢', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Ê£ÄÊü•‰∏ªÊéßÊùøÊòØÂê¶ÊçüÂùèÔºåÂ¶ÇÊûúÊçüÂùèÔºåËØ∑Êõ¥Êç¢‰∏ªÊéßÊùøÔºõ2.Ê£ÄÊü•ËΩØ‰ª∂ÁâàÊú¨ÊòØÂê¶ÂÖºÂÆπÔºåËã•‰∏çÂÖºÂÆπÔºåËØ∑ÈáçÊñ∞ÂçáÁ∫ßÊ≠£Á°ÆÁöÑËΩØ‰ª∂ÁâàÊú¨'},
                           'ÁîµÊ∫êÊùøÊäÄÊúØÊä•Ë≠¶': {'ÂéüÂõ†':'1.ÁîµÊ±†1ÂèëÁîüÊïÖÈöúÁ±ªÊä•Ë≠¶;2.ÁîµÊ±†2ÂèëÁîüÊïÖÈöúÁ±ªÊä•Ë≠¶', 'Ëß£ÂÜ≥ÂäûÊ≥ï': '1.Êõ¥Êç¢ÁîµÊ±†1;2.Êõ¥Êç¢ÁîµÊ±†2'},
                           'ÁîµÊ±†1ÊïÖÈöú01':{'ÂéüÂõ†':'ÁîµÊ±†1Ê∏©Â∫¶ÂºÇÂ∏∏Ôºå‰∏çËÉΩÂÖÖÁîµ;','Ëß£ÂÜ≥ÂäûÊ≥ï':'Êõ¥Êç¢ÁîµÊ±†1'},
                           'ÁîµÊ±†1ÊïÖÈöú02': {'ÂéüÂõ†': 'ÁîµÊ±†1ÂÖÖÁîµÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†1'},
                           'ÁîµÊ±†1ÊïÖÈöú03': {'ÂéüÂõ†': 'ÁîµÊ±†1ËÄÅÂåñ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†1'},
                           'ÁîµÊ±†1ÊïÖÈöú04': {'ÂéüÂõ†': 'ÁîµÊ±†1ÈÄöËÆØÂºÇÂ∏∏', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†1'},
                           'ÁîµÊ±†1ÊïÖÈöú05': {'ÂéüÂõ†': 'ÁîµÊ±†1ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†1'},
                           'ÁîµÊ±†2ÊïÖÈöú01':{'ÂéüÂõ†':  'ÁîµÊ±†2Ê∏©Â∫¶ÂºÇÂ∏∏Ôºå‰∏çËÉΩÂÖÖÁîµ;','Ëß£ÂÜ≥ÂäûÊ≥ï':'Êõ¥Êç¢ÁîµÊ±†2'},
                           'ÁîµÊ±†2ÊïÖÈöú02': {'ÂéüÂõ†': 'ÁîµÊ±†2ÂÖÖÁîµÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†2'},
                           'ÁîµÊ±†2ÊïÖÈöú03': {'ÂéüÂõ†': 'ÁîµÊ±†2ËÄÅÂåñ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†2'},
                           'ÁîµÊ±†2ÊïÖÈöú04': {'ÂéüÂõ†': 'ÁîµÊ±†2ÈÄöËÆØÂºÇÂ∏∏', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†2'},
                           'ÁîµÊ±†2ÊïÖÈöú05': {'ÂéüÂõ†': 'ÁîµÊ±†2ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Êõ¥Êç¢ÁîµÊ±†2'},
                           'C02Ê®°ÂùóÊïÖÈöú': {'ÂéüÂõ†': '1:CO2Ê†°Èõ∂Â§±Ë¥•;2:CO2ÂàùÂßãÂåñÈîôËØØ;3:CO2Ëá™Ê£ÄÈîôËØØ;4:CO2Á°¨‰ª∂ÈîôËØØ;5:CO2ÈÄöËÆØÂÅúÊ≠¢;6:CO2Ê†°Èõ∂ÈîôËØØ', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'1.1Ê£ÄÊü•CO2‰º†ÊÑüÂô®ÁÆ°Ë∑ØËøûÊé•ÊòØÂê¶Ê≠£Â∏∏ÔºåÈáçÊñ∞Ê†°Èõ∂Ôºõ1.2Â¶ÇÊûú‰ªçÁÑ∂Âá∫Áé∞ÈóÆÈ¢òÔºåËØ∑Êõ¥Êç¢ CO2 Ê®°Âùó„ÄÇ2.1ÈáçÊñ∞ÊèíÊãî CO2 Ê®°ÂùóÔºõ2.2Êõ¥Êç¢ CO2 Ê®°Âùó„ÄÇ3.1ÈáçÊñ∞ÊèíÊãî CO2 Ê®°ÂùóÔºõ3.2Êõ¥Êç¢CO2Ê®°Âùó„ÄÇ4.1Ê£ÄÊü•‰º†ÊÑüÂô®ÊòØÂê¶Ê≠£Á°ÆËøûÊé•Ôºõ4.2Â¶ÇÊûúËøûÊé•Ê≠£Á°ÆÔºå‰ªçÁÑ∂Âá∫Áé∞ËØ•Êä•Ë≠¶ÔºåËØ∑Êõ¥Êç¢CO2Ê®°Âùó„ÄÇ5.1Ê£ÄÊü•CO2‰∏é‰∏ªÊéßÊùøËøûÊé•Á∫øÊòØÂê¶ÊúâÈóÆÈ¢òÔºåÂ¶ÇÊûúÊòØËØ∑ÈáçÊñ∞ÊèíÊãîÊàñÊõ¥Êç¢ÈÄöËÆØÁ∫øÔºõ5.2Ê£ÄÊü•CO2‰∏é‰∏ªÊéßÊùøÊòØÂê¶ÊúâÊçüÂùèÔºåÂ¶ÇÊûúÊçüÂùèËØ∑Êõ¥Êç¢„ÄÇ6.1ÊåâÁÖß‰∏ªÊµÅCO2Ê†°Èõ∂ÁöÑÊèêÁ§∫ÔºåÊ£ÄÊü•Ê†°Èõ∂ÊñπÊ≥ïÊòØÂê¶Ê≠£Á°ÆÔºåÂ¶ÇÊûúÊúâËØØÔºåËØ∑ÊåâÁÖßÊ≠£Á°ÆÁöÑÊñπÊ≥ïÈáçÊñ∞Ê†°Èõ∂Ôºõ6.2Ê£ÄÊü•‰∏ªÊµÅ CO2 ÊòØÂê¶ÊúâÊçüÂùèÔºåÂ¶ÇÊûúÊçüÂùèÔºåËØ∑Êõ¥Êç¢„ÄÇ'},
                           'C02ÈÄöËÆØÈîôËØØ': {'ÂéüÂõ†': '1.CO2 Ê®°ÂùóÈÄöËÆØÁ∫øÊé•Ëß¶‰∏çÂ•ΩÔºõ2.CO2 Ê®°ÂùóÊúâÈóÆÈ¢ò„ÄÇ', 'Ëß£ÂÜ≥ÊñπÊ≥ï': '1.Ê£ÄÊü•„ÄÅÈáçÊñ∞ÊèíÊãî CO2 Ê®°ÂùóÈÄöËÆØÁ∫øÔºõ2.Êõ¥Êç¢ CO2 Ê®°Âùó„ÄÇ'},
                           'ÂàÜÈíüÈÄöÊ∞îÈáèËøá‰Ωé':{'ÂéüÂõ†': 'ÊΩÆÊ∞îÂÄºÊ≤°ÊúâËææÂà∞ËÆæÂÆöÂÄº','Ëß£ÂÜ≥ÊñπÊ≥ï': 'Ê£ÄÊü•ÁÆ°ÈÅìÊòØÂê¶ÊòØÂê¶Ê≥ÑÈú≤'},
                           'ÂÆ§ÊÉ†':{'ÂéüÂõ†': 'ÊΩÆÊ∞îÂÄºÊ≤°ÊúâËææÂà∞ËÆæÂÆöÂÄº','Ëß£ÂÜ≥ÊñπÊ≥ï': 'Ê£ÄÊü•ÁÆ°ÈÅìÊòØÂê¶ÊòØÂê¶Ê≥ÑÈú≤'},
                           'ÁîµÊ±†Êú™ÂèëÁé∞':{'ÂéüÂõ†': 'Ê≤°ÊúâÊ£ÄÊµãÂà∞ÁîµÊ±†','Ëß£ÂÜ≥ÊñπÊ≥ï': 'Ê£ÄÊü•ÁîµÊ±†ÊòØÂê¶ÂÆâË£Ö'},
                           'None':{'ÂéüÂõ†':'None','Ëß£ÂÜ≥ÊñπÊ≥ï':'None'}}#ÁßëÊõºÊï∞ÊçÆ
            mindray_fault = {}#ËøàÂáØÁëûÊï∞ÊçÆcomen_faut mindray_fault
            aeonmed_fault ={'Ê∞îÈÅìÂéãÂäõÈ´ò': {'ÂéüÂõ†Ôºà‰ΩéÁ∫ßÔºâ': 'Ê∞îÈÅìÂéãÂäõÂú®‰∏Ä‰∏™ÂëºÂê∏Âë®ÊúüÂÜÖÈ´ò‰∫éËÆæÂÆöÂÄº„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ïÔºà‰ΩéÁ∫ßÔºâ': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñËÄÖÊåÅÁª≠15ÁßíÊ∞îÈÅìÂéãÂäõ‰Ωé‰∫éËÆæÂÆöÈôêÂÄº',
                                         'ÂéüÂõ†ÔºàÁ∫¢Ëâ≤È´òÁ∫ßÔºâ': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊ∞îÈÅìÂéãÂäõ‰Ωé‰∫éËÆæÂÆöÈôêÂÄº„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ïÔºàÁ∫¢Ëâ≤È´òÁ∫ßÔºâ': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñËÄÖÊåÅÁª≠15ÁßíÊ∞îÈÅìÂéãÂäõÈ´ò‰∫éËÆæÂÆöÈôêÂÄº'},
                            'Ê≥ÑÊºè': {'ÂéüÂõ†': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñ10ÁßíÁõëÊµãÁöÑÂàÜÈíüÊºèÊ∞îÈáèÈ´ò‰∫éÁõëÊµãÁöÑÂàÜÈíüÈÄöÊ∞îÈáè', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñ10ÁßíÁõëÊµãÁöÑÂàÜÈíüÊºèÊ∞îÈáèÂú®Ê≠£Â∏∏ËåÉÂõ¥'},
                            'Ê∞ßÊ∞î‰∏çË∂≥': {'ÂéüÂõ†Ôºà‰ΩéÁ∫ßÔºâ': 'Ê∞ßÊ∞îÊ∞îÊ∫êÂéãÂäõ‰Ωé‰∫é160KPaÔºå‰∏îÊ∞ßÊ∞îÊµìÂ∫¶ËÆæ‰∏∫21%', 'Ëß£ÂÜ≥ÂäûÊ≥ïÔºà‰ΩéÁ∫ßÔºâ': 'Ê∞ßÊ∞îÊ∞îÊ∫êÂéãÂäõËÆæ‰∏∫160KPa',
                                        'ÂéüÂõ†ÔºàÁ∫¢Ëâ≤È´òÁ∫ßÔºâ': 'Ê∞ßÊ∞îÊ∞îÊ∫êÂéãÂäõ‰Ωé‰∫é160KPa%', 'Ëß£ÂÜ≥ÂäûÊ≥ïÔºàÁ∫¢Ëâ≤È´òÁ∫ßÔºâ': 'Ê∞ßÊ∞îÊ∞îÊ∫êÂéãÂäõÈ´ò‰∫é160KPa',},
                            '‰∫§ÊµÅÁîµÊïÖÈöú': {'ÂéüÂõ†': 'ÂèëÁîü‰∫§ÊµÅÁîµÊïÖÈöú‰∏îÊ≤°ÊúâÁîµÊ±†‰æõÁîµÔºåÁîµË∑ØÊùøÂèëÂá∫Ëá≥Â∞ë120ÁßíÊä•Ë≠¶ÔºõÊúâÁîµÊ±†‰æõÁîµÊó∂Âá∫Áé∞‚Äò‰∫§ÊµÅÁîµÊïÖÈöú‚ÄôÊä•Ë≠¶„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÈáçÊñ∞ËøûÊé•‰∫§ÊµÅÁîµ'},
                            'ÈõæÂåñ': {'ÂéüÂõ†': 'ÂºÄÂßãÈõæÂåñÊìç‰Ωú„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÈõæÂåñÊìç‰ΩúÂÆåÊàêÊàñ‰∏≠Êñ≠'},
                            'ËÇ∫Â§çÂº†': {'ÂéüÂõ†': 'ÂºÄÂßãËÇ∫Â§çÂº†Êìç‰Ωú„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËÇ∫Â§çÂº†Êìç‰ΩúÂÆåÊàêÊàñ‰∏≠Êñ≠'},
                            'ÂÜÖÈÉ®ÁîµÊ±†ÈúÄË¶ÅÊ†°È™å': {'ÂéüÂõ†': 'ÂÜÖÈÉ®ÁîµÊ±†ÈúÄË¶ÅÊ†°È™å„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Ê†°È™åÂÜÖÈÉ®ÁîµÊ±†ÔºåÈáçÂêØÂëºÂê∏Êú∫'},
                            'Â§áÁî®ÁîµÊ±†ÈúÄË¶ÅÊ†°È™å': {'ÂéüÂõ†': 'Â§áÁî®ÁîµÊ±†ÈúÄË¶ÅÊ†°È™å„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Ê†°È™åÂ§áÁî®ÁîµÊ±†ÔºåÈáçÂêØÂëºÂê∏Êú∫'},
                            'ÂëºÊ∞î‰øùÊåÅ‰∏≠Êñ≠': {'ÂéüÂõ†': 'ÂëºÊ∞î‰øùÊåÅÂÄíËÆ°Êó∂ÁªìÊùüÂêéÔºåËøòÊú™ÊùæÂºÄÂëºÊ∞î‰øùÊåÅÊåâÈíÆ„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÊùæÂºÄÂëºÊ∞î‰øùÊåÅÊåâÈíÆ'},
                            'Âê∏Ê∞î‰øùÊåÅ‰∏≠Êñ≠': {'ÂéüÂõ†': 'Âê∏Ê∞î‰øùÊåÅÂÄíËÆ°Êó∂ÁªìÊùüÂêéÔºåËøòÊú™ÊùæÂºÄÂê∏Ê∞î‰øùÊåÅÊåâÈíÆ„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÊùæÂºÄÂê∏Ê∞î‰øùÊåÅÊåâÈíÆ'},
                            'ÁîµÊ±†ÁîµÈáè‰Ωé': {'ÂéüÂõ†': 'ÁîµÊ±†‰æõÁîµÊÉÖÂÜµ‰∏ãÔºåÈ¢ÑËÆ°Êú∫Âô®ËøêË°åÊó∂Èó¥Â∞ë‰∫é30ÂàÜÈíü', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Â§ñÊé•‰∫§ÊµÅÁîµ'},
                            'Ëá™‰∏ªÂëºÂê∏È¢ëÁéáÈ´ò': {'ÂéüÂõ†': 'ËøûÁª≠4‰∏™ÂëºÂê∏Âë®ÊúüÊàñËÄÖ20ÁßíËá™‰∏ªÂëºÂê∏È¢ëÁéáË∂ÖËøáËÆæÁΩÆÈôêÂÄº', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠4‰∏™ÂëºÂê∏Âë®ÊúüËá™‰∏ªÂëºÂê∏È¢ëÁéá‰Ωé‰∫éËÆæÁΩÆÈôêÂÄº'},
                            'Ê∞ßÊµìÂ∫¶‰º†ÊÑüÂô®ÁîµÂéãËøá‰Ωé': {'ÂéüÂõ†': 'Âú®‰ΩøÁî®ÂâçÊµãËØïÊúüÈó¥Ê£ÄÊµã', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÈáçÂ§ç‰ΩøÁî®ÂâçÊµãËØïÔºåÊµãÈáè‰º†ÊÑüÂô®‰ø°Âè∑ÊòØÂê¶Ê≠£Â∏∏'},
                            'Ê∞ßÊµìÂ∫¶È´ò': {'ÂéüÂõ†': 'ËøûÁª≠30ÁßíÊ∞ßÊµìÂ∫¶ÁõëÊµãÂÄºÈ´ò‰∫éËÆæÁΩÆÂÄº6%‰ª•‰∏ä„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠30ÁßíÊ∞ßÊµìÂ∫¶ÁõëÊµãÂÄº‰Ωé‰∫éËÆæÂÆöÂÄº6%‰ª•‰∏ä'},
                            'Ê∞ßÊµìÂ∫¶‰Ωé': {'ÂéüÂõ†': 'ËøûÁª≠30ÁßíÊ∞ßÊµìÂ∫¶ÁõëÊµãÂÄº‰Ωé‰∫éËÆæÁΩÆÂÄº6%‰ª•‰∏äÊàñËÄÖ18%‰ª•‰∏ã', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠30ÁßíÊ∞ßÊµìÂ∫¶ÁõëÊµãÂÄºÈ´ò‰∫éËÆæÂÆöÂÄº6%‰ª•‰∏äÊàñËÄÖ18%‰ª•‰∏ä'},
                            'ÂàÜÈíüÈÄöÊ∞îÈáèÈ´ò': {'ÂéüÂõ†': 'ÂëºÂê∏1ÂàÜÈíüÂêéÂàÜÈíüÈÄöÊ∞îÈáèÈ´ò‰∫éËÆæÂÆöÂÄº‰∏äÈôê', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÂàÜÈíüÈÄöÊ∞îÈáè‰Ωé‰∫éËÆæÂÆöÈôêÂÄº15Áßí'},
                            'ÂàÜÈíüÈÄöÊ∞îÈáè‰Ωé': {'ÂéüÂõ†': 'ÂàÜÈíüÈÄöÊ∞îÈáè1ÂàÜÈíüÂÜÖ‰Ωé‰∫éËÆæÂÆö‰∏ãÈôê„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÂàÜÈíüÈÄöÊ∞îÈáèÈ´ò‰∫éËÆæÂÆöÈôêÂÄºÁöÑÈÄöÊ∞îÈáè15Áßí'},
                            'Âê∏Ê∞îÊó∂Èó¥ËøáÈïø': {'ÂéüÂõ†': 'Êó†Âàõ-ËøûÁª≠‰∏âÊ¨°Âê∏Ê∞îÊó∂Èó¥Ë∂ÖËøáËÆæÁΩÆÈôêÂÄºÔºõÊúâÂàõ-ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàê‰∫∫Âê∏Ê∞îÊó∂Èó¥Ë∂ÖËøá5ÁßíÔºåÂ∞èÂÑøË∂ÖËøá2Áßí„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠3Ê¨°Âê∏Ê∞îÊó∂Èó¥Â∞è‰∫éËÆæÂÆöÈôêÂÄºÔºàÊó†ÂàõÔºâÊàñÂõ∫ÂÆöÈôêÂÄºÔºàÊúâÂàõÔºâ'},
                            'ÈõæÂåñÊìç‰Ωú‰∏≠Êñ≠': {'ÂéüÂõ†': 'ÈõæÂåñÊìç‰ΩúÂõ†‰∏∫Ê®°ÂºèÊîπÂèòËÄå‰∏≠Êñ≠', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÈõæÂåñÊìç‰ΩúÁªßÁª≠ÊàñËÄÖÈÄöËøáÊä•Ë≠¶ÈùôÈü≥ÈîÆÊ∂àÈô§'},
                            'ÂëºÊ∞îÊΩÆÊ∞îÈáè‰Ωé': {'ÂéüÂõ†Ôºà‰ΩéÁ∫ßÔºâ': 'Âú®1‰∏™ÂëºÂê∏Âë®ÊúüÂÜÖÂëºÊ∞îÊΩÆÊ∞îÈáè‰Ωé‰∫éËÆæÂÆöÂÄº„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ïÔºà‰ΩéÁ∫ßÔºâ': 'Âú®1‰∏™ÂëºÂê∏Âë®ÊúüÂÜÖÂëºÊ∞îÊΩÆÊ∞îÈáèÈ´ò‰∫éËÆæÂÆöÂÄº',
                                           'ÂéüÂõ†ÔºàÁ∫¢Ëâ≤È´òÁ∫ßÔºâ': 'ËøûÁª≠3‰∏™Âë®ÊúüÊàñ30ÁßíÂëºÊ∞îÊΩÆÊ∞îÈáèÂßãÁªà‰Ωé‰∫éËÆæÂÆöÂÄº„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ïÔºàÁ∫¢Ëâ≤È´òÁ∫ßÔºâ':'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñËÄÖÊåÅÁª≠30ÁßíÂëºÊ∞îÊΩÆÊ∞îÈáèÈ´ò‰∫éËÆæÂÆöÈôêÂÄº',},
                            'ÁîµÊ±†ÁîµÈáèËÄóÂ∞Ω': {'ÂéüÂõ†': 'ÁîµÊ±†‰æõÁîµÊÉÖÂÜµ‰∏ãÔºåÈ¢ÑËÆ°Êú∫Âô®ËøêË°åÊó∂Èó¥Â∞ë‰∫é10ÂàÜÈíü„ÄÇ','Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÊé•‰∫§ÊµÅÁîµ'},
                            'ÂÜÖÈÉ®ÈîôËØØ': {'ÂéüÂõ†': 'ÂÜÖÈÉ®ÈîôËØØ„ÄÇ', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÈáçÂêØËÆæÂ§áÔºõÂ¶ÇÊûúÊä•Ë≠¶ÂÜçÊ¨°ÂèëÁîüÂÅúÊ≠¢‰ΩøÁî®ÂëºÂê∏Êú∫ÔºåËÆ∞ÂΩï‰ª£Á†ÅÂπ∂ËÅîÁ≥ªÂîÆÂêéÊúçÂä°‰∫∫Âëò'},
                            'BDUÈÄö‰ø°ÊïÖÈöú': {'ÂéüÂõ†': 'ÂëºÂê∏Êú∫BDUÂá∫Áé∞ÈÄö‰ø°ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'ÈáçÂêØËÆæÂ§áÔºåÂ¶ÇÊûúÂ§öÊ¨°ÂèëÁîüÔºåËØ∑ËÅîÁ≥ªÂîÆÂêéÊúçÂä°‰∫∫Âëò'},
                            'PSÈÄö‰ø°ÊïÖÈöú': {'ÂéüÂõ†': 'ÂëºÂê∏Êú∫PSÂá∫Áé∞ÈÄö‰ø°ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'ÈáçÂêØËÆæÂ§áÔºåÂ¶ÇÊûúÂ§öÊ¨°ÂèëÁîüÔºåËØ∑ËÅîÁ≥ªÂîÆÂêéÊúçÂä°‰∫∫Âëò'},
                            'ÂëºÊ∞îÈòÄÂä†ÁÉ≠Âô®ÊïÖÈöú': {'ÂéüÂõ†': 'Á≥ªÁªüÊ£ÄÊü•ÂëºÊ∞îÈòÄÂä†ÁÉ≠Âô®ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'ËÅîÁ≥ªÂîÆÂêéÊúçÂä°‰∫∫Âëò'},
                            'Ê∞îÈÅìÂéãÂäõÊåÅÁª≠È´ò': {'ÂéüÂõ†': 'Ê∞îÈÅìÂéãÂäõÊåÅÁª≠15ÁßíË∂ÖËøáPEEP15cmH2OÔºåÂëºÊ∞îÈòÄÊâìÂºÄÈáäÊîæÂéãÂäõ', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'ËøûÁª≠5ÁßíË∂ÖÂá∫PEEPÂÄºÂ∞è‰∫é15cmH2O'},
                            'Á™íÊÅØ': {'ÂéüÂõ†': 'Ë∂ÖËøáÁ™íÊÅØÊä•Ë≠¶ÈôêÂÄºÁöÑÊó∂Èó¥ÂÜÖÔºåÊ≤°ÊúâËß¶ÂèëÂëºÂê∏Âë®Êúü', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ÂèÇÁÖß11.1.3ÈÄÄÂá∫Â§á‰ªΩÈÄöÊ∞î'},
                            'PEEPÈ´ò': {'ÂéüÂõ†': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüPEEPÂÄºÈ´ò‰∫éËÆæÂÆöÈôêÂÄº','Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñËÄÖÊåÅÁª≠15ÁßíPEEPÂÄº‰Ωé‰∫éËÆæÂÆöÈôêÂÄº'},
                            'ÁÆ°Ë∑ØËÑ±ËêΩ': {'ÂéüÂõ†': 'ÂëºÂê∏ÁÆ°Ë∑ØÊñ≠ÂºÄ', 'Ëß£ÂÜ≥ÂäûÊ≥ï':'ÈáçÊñ∞ËøûÊé•ÂëºÂê∏ÁÆ°Ë∑Ø'},
                            'ÁÆ°Ë∑ØÈòªÂ°û': {'ÂéüÂõ†': 'ÂëºÂê∏ÁÆ°Ë∑ØË¢´ÈòªÂ°û', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Ëß£Èô§ÈòªÂ°û'},
                            'Ê≥ÑÊºèË∂ÖÂá∫ËåÉÂõ¥': {'ÂéüÂõ†': '‰ªÖÂú®NIVÊ®°Âºè‰∏ã-ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊ≥ÑÈú≤Ë∂ÖËøáÊúÄÂ§ßÁöÑË°•ÂÅøÂÄº','Ëß£ÂÜ≥ÂäûÊ≥ï':'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊ≥ÑÈú≤‰Ωé‰∫éÊúÄÂ§ßË°•ÂÅøÈáè'},
                            'Ê∞îÈÅìÂéãÂäõ‰Ωé': {'ÂéüÂõ†': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊ∞îÈÅìÂéãÂäõ‰Ωé‰∫éËÆæÂÆöÈôêÂÄº', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñËÄÖÊåÅÁª≠15ÁßíÊ∞îÈÅìÂéãÂäõÈ´ò‰∫éËÆæÂÆöÈôêÂÄº'},
                            'PEEP‰Ωé': {'ÂéüÂõ†': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüPEEPÂÄº‰Ωé‰∫éËÆæÂÆöÈôêÂÄº', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'ËøûÁª≠3‰∏™ÂëºÂê∏Âë®ÊúüÊàñËÄÖÊåÅÁª≠15ÁßíPEEPÂÄºÈ´ò‰∫éËÆæÂÆöÈôêÂÄº'},
                            'ÈÄö‰ø°ÊïÖÈöú': {'ÂéüÂõ†': 'ÈÄö‰ø°ÊïÖÈöú', 'Ëß£ÂÜ≥ÂäûÊ≥ï': 'Â±èÂπï‰∏é‰∏ªÊú∫ÁöÑËøûÊé•Á∫øÊé•Á¥ß'},
                            }
            test_texts = []
            final_fault = {}#ÊúÄÁªàË∞ÉÁî®Êï∞ÊçÆ
            for d in reversed(pred_boxes):
                c, conf, id = int(d.cls), float(d.conf) if conf else None, None if d.id is None else int(d.id.item())
                text_num.append(c)
                if c == 5:
                    type_number = 'comen'
                if c == 7:
                    type_number = 'mindray'
                if c == 11:
                    type_number = 'aeonmed'
                    #print('Ë∞äÂÆâ')
                if c ==6:#ÂºÄÊú∫Ëá™Ê£ÄÊä•Èîô
                    #print(d.xyxy[0][0].item())
                    set_label =True
                    x1 = int(d.xyxy[0][0].item())
                    y1 = int(d.xyxy[0][1].item())
                    x2 = int(d.xyxy[0][2].item())
                    y2 = int(d.xyxy[0][3].item())
                    #print(self.orig_img)
                    box_image = self.orig_img[y1:y2, x1:x2]
                    start = time.time()
                    label = ocr.recognize_text(images=[box_image])
                    spend = time.time()-start
                    #print(label)ÊâìÂç∞ÊñáÂ≠óËØÜÂà´ÂàùÊ¨°ÁªìÊûú
                    #print(spend,'text time')ÊñáÂ≠óËØÜÂà´Êó∂Èó¥
                    #delete_char1 = '!'
                    #delete_char2 = 'ÔºÅ'
                    # Âú®‰Ω†ÁöÑÁ§∫‰æãÊï∞ÊçÆ‰∏≠ÂØªÊâæÊñáÊú¨‰∏∫ 'ÈÄöËøá' ÁöÑÂ≠óÂÖ∏ÁöÑÁ¥¢ÂºïÂè∑
                    """indices  = self.find_dict_index_by_text(label[0]['data'],'Â§±Ë¥•')
                    print("Â≠óÂÖ∏Âú®Êï∞ÁªÑ‰∏≠ÁöÑÁ¥¢ÂºïÂè∑:", indices)"""
                    data = label[0]['data']
                    sorted_data = sorted(data,key=lambda x: (x['text_box_position'][0][1], x['text_box_position'][0][0]))
                    print(sorted_data)#ÊéíÂ∫è‰πãÂêéÁöÑÊñáÂ≠óËØÜÂà´ÂàóË°®
                    #result = text.replace('!', '').replace('ÔºÅ', '')
                    if len(sorted_data)>15:
                        if len(sorted_data[0]['text'])==2:
                            for i, entry in enumerate(sorted_data):
                                if entry['text'] == 'Â§±Ë¥•' or entry['text'] == 'Â§±Ë¥≠' and i + 1 < len(label[0]['data']):
                                    if i == 0:
                                        test_texts.append('Ê∂°ËΩÆËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 2:
                                        test_texts.append('02ÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 4:
                                        test_texts.append('Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 6:
                                        test_texts.append('ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 8:
                                        test_texts.append('ÂéãÂäõ‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 10:
                                        test_texts.append('ÂëºÊ∞îÈòÄËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 12:
                                        test_texts.append('ÂÆâÂÖ®ÈòÄËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 14:
                                        test_texts.append('Ê≥ÑÊºèÈáèËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 16:
                                        test_texts.append('È°∫Â∫îÊÄßËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 18:
                                        test_texts.append('Ê≥ÑÊºèÈáèËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 20:
                                        test_texts.append('Ê≥ÑÊºèÈáèËá™Ê£ÄÂ§±Ë¥•')
                        else:
                            for i, entry in enumerate(sorted_data):
                                if entry['text'] == 'Â§±Ë¥•' or entry['text'] == 'Â§±Ë¥≠'and i + 1 < len(label[0]['data']):
                                    if i == 1:
                                        test_texts.append('Ê∂°ËΩÆËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 3:
                                        test_texts.append('02ÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 5:
                                        test_texts.append('Âê∏Ê∞îÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 7:
                                        test_texts.append('ÂëºÊ∞îÊµÅÈáè‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 9:
                                        test_texts.append('ÂéãÂäõ‰º†ÊÑüÂô®Ëá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 11:
                                        test_texts.append('ÂëºÊ∞îÈòÄËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 13:
                                        test_texts.append('ÂÆâÂÖ®ÈòÄËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 15:
                                        test_texts.append('Ê≥ÑÊºèÈáèËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 17:
                                        test_texts.append('È°∫Â∫îÊÄßËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 19:
                                        test_texts.append('Ê≥ÑÊºèÈáèËá™Ê£ÄÂ§±Ë¥•')
                                    elif i == 21:
                                        test_texts.append('Ê≥ÑÊºèÈáèËá™Ê£ÄÂ§±Ë¥•')
                    else:
                        for item in sorted_data:
                            if 'Â§±Ë¥•' in item['text']:
                                test_texts.append(item['text'])
                    print(test_texts)#ÊâìÂç∞Ëá™Ê£ÄÈîôËØØ‰ø°ÊÅØ
                    name = ('' if id is None else f'id:{id} ') + names[c]
                    label = (f'{name} {conf:.2f}' if conf else name) if labels else None
                    annotator.box_label(d.xyxy.squeeze(), label, color=colors(c, True))

                if c ==4:#ËøêË°å‰∏≠Êä•Ë≠¶
                    #print(d.xyxy[0][0].item())
                    x1 = int(d.xyxy[0][0].item())
                    y1 = int(d.xyxy[0][1].item())
                    x2 = int(d.xyxy[0][2].item())
                    y2 = int(d.xyxy[0][3].item())
                    #print(self.orig_img)
                    box_image = self.orig_img[y1:y2, x1:x2]
                    start = time.time()
                    label = ocr.recognize_text(images=[box_image])
                    spend = time.time()-start
                    #print(spend,'text time')ÊñáÂ≠óËØÜÂà´Ëä±Ë¥πÊó∂Èó¥
                    #delete_char1 = '!'
                    #delete_char2 = 'ÔºÅ'
                    item = label[0]['data']
                    for text in item:
                        text = text['text']
                        if len(text) > 1:
                            result1 = text.replace('!', '').replace('ÔºÅ', '').replace('Ôºà5Ôºâ','').replace('(1Ôºâ','')
                            warn_fault.append(result1)
                            label1 = (f'{result1} {conf:.2f}' if conf else result1) if labels else None
                            annotator.box_label(d.xyxy.squeeze(), label1, color=colors(c, True))
                    first_chinese_index = -1
                    # ÊâæÂà∞Á¨¨‰∏Ä‰∏™Ê±âÂ≠óÁöÑÁ¥¢Âºï
                    if len(warn_fault)==1:
                        for i, char in enumerate(warn_fault[0]):
                            if '\u4e00' <= char <= '\u9fff':
                                first_chinese_index = i
                                break
                        # ÊèêÂèñÁ¨¨‰∏Ä‰∏™Ê±âÂ≠óÂèäÂÖ∂ÂêéÈù¢ÁöÑÊâÄÊúâ‰ø°ÊÅØ
                        if first_chinese_index != -1:
                            chinese_and_after = warn_fault[0][first_chinese_index:]
                            warn_fault.append(chinese_and_after)
                        else:
                            print("Êú™ÊâæÂà∞Ê±âÂ≠ó")
                    print(warn_fault)#ÊâìÂç∞ÈîôËØØ‰ø°ÊÅØ

                else:
                    name = ('' if id is None else f'id:{id} ') + names[c]
                    label = (f'{name} {conf:.2f}' if conf else name) if labels else None
                    annotator.box_label(d.xyxy.squeeze(), label, color=colors(c, True))
            if type_number == 'comen':#Ê†πÊçÆÂûãÂè∑ÈÄâÊã©ÈîôËØØÂ∫îÂØπÂäûÊ≥ï
                final_fault = comen_faut
            elif type_number == 'aeonmed':
                final_fault = aeonmed_fault
            elif type_number == 'mindray':
                final_fault = comen_faut
            #print(final_fault)ÊâìÂç∞Ë∞ÉÁî®ÂûãÂè∑ÈîôËØØÊï∞ÊçÆÂ∫ì
            if set_label:#Ê†áÂøó‰ΩçÂà§Êñ≠ ÊòØÂê¶Ëá™Ê£ÄÊä•ÈîôÂíåËøêË°å‰∏≠Êä•Èîô
                for test in test_texts:#Ëá™Ê£ÄÈîôËØØ
                    if test in final_fault:
                        final_text[test] = final_fault[test]
                        # Handle the case where warn_fault is not in final_fault
                    else:
                        final_text = {f'Â§±Ë¥•{i + 1}': text for i, text in enumerate(test_texts)}
            else:
                for test in warn_fault:#Êä•Ë≠¶ÈîôËØØ
                    if test in final_fault:
                        final_text[test] = final_fault[test]
                    if test == 'ÂÆ§ÊÅØ':
                        final_text['Á™íÊÅØ'] = final_fault['Á™íÊÅØ']
            print(final_text)#ÊúÄÁªàÊä•Èîô‰ø°ÊÅØ
            #print(text_num)Ê£ÄÊµãÂà∞ÂêÑÁßçÁõÆÊ†áÊ°ÜÁöÑÂ∫èÂè∑ÔºàÂ∫èÂè∑Âêådata.yaml‰∏ÄÊ†∑Ôºâ

        # Plot Classify results
        if pred_probs is not None and show_probs:
            text = ',\n'.join(f'{names[j] if names else j} {pred_probs.data[j]:.2f}' for j in pred_probs.top5)
            x = round(self.orig_shape[0] * 0.03)
            annotator.text([x, x], text, txt_color=(255, 255, 255))  # TODO: allow setting colors

        # Plot Pose results
        if self.keypoints is not None:
            for k in reversed(self.keypoints.data):
                annotator.kpts(k, self.orig_shape, radius=kpt_radius, kpt_line=kpt_line)

        return annotator.result(),final_text#ÂõæÂÉè

    def find_dict_index_by_text(self, result_data, text):
        indices = []
        for i, dictionary in enumerate(result_data):
            if 'text' in dictionary and dictionary['text'] == text:
                indices.append(i)
        return indices

    def verbose(self):
        """Return log string for each task."""
        log_string = ''
        probs = self.probs
        boxes = self.boxes
        if len(self) == 0:
            return log_string if probs is not None else f'{log_string}(no detections), '
        if probs is not None:
            log_string += f"{', '.join(f'{self.names[j]} {probs.data[j]:.2f}' for j in probs.top5)}, "
        if boxes:
            for c in boxes.cls.unique():
                n = (boxes.cls == c).sum()  # detections per class
                log_string += f"{n} {self.names[int(c)]}{'s' * (n > 1)}, "
        return log_string

    def save_txt(self, txt_file, save_conf=False):
        """
        Save predictions into txt file.

        Args:
            txt_file (str): txt file path.
            save_conf (bool): save confidence score or not.
        """
        boxes = self.boxes
        masks = self.masks
        probs = self.probs
        kpts = self.keypoints
        texts = []
        if probs is not None:
            # Classify
            [texts.append(f'{probs.data[j]:.2f} {self.names[j]}') for j in probs.top5]
        elif boxes:
            # Detect/segment/pose
            for j, d in enumerate(boxes):
                c, conf, id = int(d.cls), float(d.conf), None if d.id is None else int(d.id.item())
                line = (c, *d.xywhn.view(-1))
                if masks:
                    seg = masks[j].xyn[0].copy().reshape(-1)  # reversed mask.xyn, (n,2) to (n*2)
                    line = (c, *seg)
                if kpts is not None:
                    kpt = torch.cat((kpts[j].xyn, kpts[j].conf[..., None]), 2) if kpts[j].has_visible else kpts[j].xyn
                    line += (*kpt.reshape(-1).tolist(), )
                line += (conf, ) * save_conf + (() if id is None else (id, ))
                texts.append(('%g ' * len(line)).rstrip() % line)

        if texts:
            Path(txt_file).parent.mkdir(parents=True, exist_ok=True)  # make directory
            with open(txt_file, 'a') as f:
                f.writelines(text + '\n' for text in texts)

    def save_crop(self, save_dir, file_name=Path('im.jpg')):
        """
        Save cropped predictions to `save_dir/cls/file_name.jpg`.

        Args:
            save_dir (str | pathlib.Path): Save path.
            file_name (str | pathlib.Path): File name.
        """
        if self.probs is not None:
            LOGGER.warning('WARNING ‚ö†Ô∏è Classify task do not support `save_crop`.')
            return
        for d in self.boxes:
            save_one_box(d.xyxy,
                         self.orig_img.copy(),
                         file=Path(save_dir) / self.names[int(d.cls)] / f'{Path(file_name).stem}.jpg',
                         BGR=True)

    def tojson(self, normalize=False):
        """Convert the object to JSON format."""
        if self.probs is not None:
            LOGGER.warning('Warning: Classify task do not support `tojson` yet.')
            return

        import json

        # Create list of detection dictionaries
        results = []
        data = self.boxes.data.cpu().tolist()
        h, w = self.orig_shape if normalize else (1, 1)
        for i, row in enumerate(data):  # xyxy, track_id if tracking, conf, class_id
            box = {'x1': row[0] / w, 'y1': row[1] / h, 'x2': row[2] / w, 'y2': row[3] / h}
            conf = row[-2]
            class_id = int(row[-1])
            name = self.names[class_id]
            result = {'name': name, 'class': class_id, 'confidence': conf, 'box': box}
            if self.boxes.is_track:
                result['track_id'] = int(row[-3])  # track ID
            if self.masks:
                x, y = self.masks.xy[i][:, 0], self.masks.xy[i][:, 1]  # numpy array
                result['segments'] = {'x': (x / w).tolist(), 'y': (y / h).tolist()}
            if self.keypoints is not None:
                x, y, visible = self.keypoints[i].data[0].cpu().unbind(dim=1)  # torch Tensor
                result['keypoints'] = {'x': (x / w).tolist(), 'y': (y / h).tolist(), 'visible': visible.tolist()}
            results.append(result)

        # Convert detections to JSON
        return json.dumps(results, indent=2)


class Boxes(BaseTensor):
    """
    A class for storing and manipulating detection boxes.

    Args:
        boxes (torch.Tensor | numpy.ndarray): A tensor or numpy array containing the detection boxes,
            with shape (num_boxes, 6) or (num_boxes, 7). The last two columns contain confidence and class values.
            If present, the third last column contains track IDs.
        orig_shape (tuple): Original image size, in the format (height, width).

    Attributes:
        xyxy (torch.Tensor | numpy.ndarray): The boxes in xyxy format.
        conf (torch.Tensor | numpy.ndarray): The confidence values of the boxes.
        cls (torch.Tensor | numpy.ndarray): The class values of the boxes.
        id (torch.Tensor | numpy.ndarray): The track IDs of the boxes (if available).
        xywh (torch.Tensor | numpy.ndarray): The boxes in xywh format.
        xyxyn (torch.Tensor | numpy.ndarray): The boxes in xyxy format normalized by original image size.
        xywhn (torch.Tensor | numpy.ndarray): The boxes in xywh format normalized by original image size.
        data (torch.Tensor): The raw bboxes tensor (alias for `boxes`).

    Methods:
        cpu(): Move the object to CPU memory.
        numpy(): Convert the object to a numpy array.
        cuda(): Move the object to CUDA memory.
        to(*args, **kwargs): Move the object to the specified device.
    """

    def __init__(self, boxes, orig_shape) -> None:
        """Initialize the Boxes class."""
        if boxes.ndim == 1:
            boxes = boxes[None, :]
        n = boxes.shape[-1]
        assert n in (6, 7), f'expected `n` in [6, 7], but got {n}'  # xyxy, track_id, conf, cls
        super().__init__(boxes, orig_shape)
        self.is_track = n == 7
        self.orig_shape = orig_shape

    @property
    def xyxy(self):
        """Return the boxes in xyxy format."""
        return self.data[:, :4]

    @property
    def conf(self):
        """Return the confidence values of the boxes."""
        return self.data[:, -2]

    @property
    def cls(self):
        """Return the class values of the boxes."""
        return self.data[:, -1]

    @property
    def id(self):
        """Return the track IDs of the boxes (if available)."""
        return self.data[:, -3] if self.is_track else None

    @property
    @lru_cache(maxsize=2)  # maxsize 1 should suffice
    def xywh(self):
        """Return the boxes in xywh format."""
        return ops.xyxy2xywh(self.xyxy)

    @property
    @lru_cache(maxsize=2)
    def xyxyn(self):
        """Return the boxes in xyxy format normalized by original image size."""
        xyxy = self.xyxy.clone() if isinstance(self.xyxy, torch.Tensor) else np.copy(self.xyxy)
        xyxy[..., [0, 2]] /= self.orig_shape[1]
        xyxy[..., [1, 3]] /= self.orig_shape[0]
        return xyxy

    @property
    @lru_cache(maxsize=2)
    def xywhn(self):
        """Return the boxes in xywh format normalized by original image size."""
        xywh = ops.xyxy2xywh(self.xyxy)
        xywh[..., [0, 2]] /= self.orig_shape[1]
        xywh[..., [1, 3]] /= self.orig_shape[0]
        return xywh


class Masks(BaseTensor):
    """
    A class for storing and manipulating detection masks.

    Attributes:
        xy (list): A list of segments in pixel coordinates.
        xyn (list): A list of normalized segments.

    Methods:
        cpu(): Returns the masks tensor on CPU memory.
        numpy(): Returns the masks tensor as a numpy array.
        cuda(): Returns the masks tensor on GPU memory.
        to(device, dtype): Returns the masks tensor with the specified device and dtype.
    """

    def __init__(self, masks, orig_shape) -> None:
        """Initialize the Masks class with the given masks tensor and original image shape."""
        if masks.ndim == 2:
            masks = masks[None, :]
        super().__init__(masks, orig_shape)

    @property
    @lru_cache(maxsize=1)
    def xyn(self):
        """Return normalized segments."""
        return [
            ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=True)
            for x in ops.masks2segments(self.data)]

    @property
    @lru_cache(maxsize=1)
    def xy(self):
        """Return segments in pixel coordinates."""
        return [
            ops.scale_coords(self.data.shape[1:], x, self.orig_shape, normalize=False)
            for x in ops.masks2segments(self.data)]


class Keypoints(BaseTensor):
    """
    A class for storing and manipulating detection keypoints.

    Attributes:
        xy (torch.Tensor): A collection of keypoints containing x, y coordinates for each detection.
        xyn (torch.Tensor): A normalized version of xy with coordinates in the range [0, 1].
        conf (torch.Tensor): Confidence values associated with keypoints if available, otherwise None.

    Methods:
        cpu(): Returns a copy of the keypoints tensor on CPU memory.
        numpy(): Returns a copy of the keypoints tensor as a numpy array.
        cuda(): Returns a copy of the keypoints tensor on GPU memory.
        to(device, dtype): Returns a copy of the keypoints tensor with the specified device and dtype.
    """

    @smart_inference_mode()  # avoid keypoints < conf in-place error
    def __init__(self, keypoints, orig_shape) -> None:
        """Initializes the Keypoints object with detection keypoints and original image size."""
        if keypoints.ndim == 2:
            keypoints = keypoints[None, :]
        if keypoints.shape[2] == 3:  # x, y, conf
            mask = keypoints[..., 2] < 0.5  # points with conf < 0.5 (not visible)
            keypoints[..., :2][mask] = 0
        super().__init__(keypoints, orig_shape)
        self.has_visible = self.data.shape[-1] == 3

    @property
    @lru_cache(maxsize=1)
    def xy(self):
        """Returns x, y coordinates of keypoints."""
        return self.data[..., :2]

    @property
    @lru_cache(maxsize=1)
    def xyn(self):
        """Returns normalized x, y coordinates of keypoints."""
        xy = self.xy.clone() if isinstance(self.xy, torch.Tensor) else np.copy(self.xy)
        xy[..., 0] /= self.orig_shape[1]
        xy[..., 1] /= self.orig_shape[0]
        return xy

    @property
    @lru_cache(maxsize=1)
    def conf(self):
        """Returns confidence values of keypoints if available, else None."""
        return self.data[..., 2] if self.has_visible else None


class Probs(BaseTensor):
    """
    A class for storing and manipulating classification predictions.

    Attributes:
        top1 (int): Index of the top 1 class.
        top5 (list[int]): Indices of the top 5 classes.
        top1conf (torch.Tensor): Confidence of the top 1 class.
        top5conf (torch.Tensor): Confidences of the top 5 classes.

    Methods:
        cpu(): Returns a copy of the probs tensor on CPU memory.
        numpy(): Returns a copy of the probs tensor as a numpy array.
        cuda(): Returns a copy of the probs tensor on GPU memory.
        to(): Returns a copy of the probs tensor with the specified device and dtype.
    """

    def __init__(self, probs, orig_shape=None) -> None:
        """Initialize the Probs class with classification probabilities and optional original shape of the image."""
        super().__init__(probs, orig_shape)

    @property
    @lru_cache(maxsize=1)
    def top1(self):
        """Return the index of top 1."""
        return int(self.data.argmax())

    @property
    @lru_cache(maxsize=1)
    def top5(self):
        """Return the indices of top 5."""
        return (-self.data).argsort(0)[:5].tolist()  # this way works with both torch and numpy.

    @property
    @lru_cache(maxsize=1)
    def top1conf(self):
        """Return the confidence of top 1."""
        return self.data[self.top1]

    @property
    @lru_cache(maxsize=1)
    def top5conf(self):
        """Return the confidences of top 5."""
        return self.data[self.top5]
